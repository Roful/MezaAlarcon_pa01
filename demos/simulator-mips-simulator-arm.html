
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<LINK href="diff-s.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="nav-div.js"></script>
</head>
<body>
<div id="left" class="src">
<pre>
<a id='leftstart' tid='rightstart'></a>
// Copyright 2011 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#<a id='9613' tid='9614', class="m">include</a> <a id='9615' tid='9616', class="m">&lt;</a><a id='9617' tid='9618', class="m">stdlib</a><a id='9619' tid='9620', class="m">.</a><a id='9621' tid='9622', class="m">h</a><a id='9623' tid='9624', class="m">&gt;</a>
#<a id='9601' tid='9602', class="m">include</a> <a id='9603' tid='9604', class="m">&lt;</a><a id='9605' tid='9606', class="m">math</a><a id='9607' tid='9608', class="m">.</a><a id='9609' tid='9610', class="m">h</a><a id='9611' tid='9612', class="m">&gt;</a>
<span class="d">#include &lt;limits.h&gt;</span>
<span class="d">#include &lt;cstdarg&gt;</span>
<span class="d">#include &quot;v8.h&quot;</span>

<span class="d">#if defined(V8_TARGET_ARCH_MIPS)</span>

<span class="d">#include &quot;disasm.h&quot;</span>
<span class="d">#include &quot;assembler.h&quot;</span>
<span class="d">#include &quot;globals.h&quot;</span>    // Need the BitCast.
<span class="d">#include &quot;mips/constants-mips.h&quot;</span>
<span class="d">#include &quot;mips/simulator-mips.h&quot;</span>


// Only build the simulator if not compiling for real MIPS hardware.
#<a id='9591' tid='9592', class="m">if</a> <a id='9593' tid='9594', class="m">defined</a><a id='9595' tid='9596', class="m">(</a><a id='9597' tid='9598', class="m">USE_SIMULATOR</a><a id='9599' tid='9600', class="m">)</a>

namespace <span class="d">v8</span> {
namespace <span class="d">internal</span> {

// Utils functions.
<span class="d">bool HaveSameSign(int32_t a, int32_t b) {
  return ((a ^ b) &gt;= 0);
}</span>


<span class="d">uint32_t get_fcsr_condition_bit(uint32_t cc) {
  if (cc == 0) {
    return 23;
  } else {
    return 24 + cc;
  }
}</span>


// This macro provides a platform independent use of sscanf. The reason for
// SScanF not being implemented in a platform independent was through
// ::v8::internal::OS in the same way as SNPrintF is that the Windows C Run-Time
// Library does not provide vsscanf.
<span class="d">#define SScanF sscanf</span>  // NOLINT

// The MipsDebugger class is used by the simulator while debugging simulated
// code.
<span class="d">class</span> <span class="d">MipsDebugger</span> {
 <span class="d">public:</span>
  <span class="d">explicit MipsDebugger(Simulator* sim)</span>;
  <span class="d">~MipsDebugger();</span>

  <a id='9581' tid='9582', class="m">void</a> <a id='9583' tid='9584', class="m">Stop</a>(<a id='9585' tid='9586', class="m">Instruction</a><a id='9587' tid='9588', class="m">*</a> <a id='9589' tid='9590', class="m">instr</a>);
  <span class="d">void Debug()</span>;
  // Print all registers with a nice formatting.
  <span class="d">void PrintAllRegs()</span>;
  <span class="d">void PrintAllRegsIncludingFPU()</span>;

 <span class="d">private:</span>
  // We set the breakpoint code to 0xfffff to easily recognize it.
  <span class="d">static const Instr kBreakpointInstr = SPECIAL | BREAK | 0xfffff &lt;&lt; 6;</span>
  <span class="d">static const Instr kNopInstr =  0x0;</span>

  <span class="d">Simulator* sim_;</span>

  <span class="d">int32_t GetRegisterValue(int regnum)</span>;
  <span class="d">int32_t GetFPURegisterValueInt(int regnum)</span>;
  <span class="d">int64_t GetFPURegisterValueLong(int regnum)</span>;
  <span class="d">float GetFPURegisterValueFloat(int regnum)</span>;
  <span class="d">double GetFPURegisterValueDouble(int regnum)</span>;
  <a id='9563' tid='9564', class="m">bool</a> <a id='9565' tid='9566', class="m">GetValue</a>(<a id='9567' tid='9568', class="m">const</a> <a id='9569' tid='9570', class="m">char</a><a id='9571' tid='9572', class="m">*</a> <a id='9573' tid='9574', class="m">desc</a>, <a id='9575' tid='9576', class="m">int32_t</a><a id='9577' tid='9578', class="m">*</a> <a id='9579' tid='9580', class="m">value</a>);

  // Set or delete a breakpoint. Returns true if successful.
  <a id='9543' tid='9544', class="m">bool</a> <a id='9545' tid='9546', class="m">SetBreakpoint</a>(<a id='9547' tid='9548', class="m">Instruction</a><a id='9549' tid='9550', class="m">*</a> <a id='9551' tid='9552', class="m">breakpc</a>);
  <a id='9499' tid='9500', class="m">bool</a> <a id='9501' tid='9502', class="m">DeleteBreakpoint</a>(<a id='9503' tid='9504', class="m">Instruction</a><a id='9505' tid='9506', class="m">*</a> <a id='9507' tid='9508', class="m">breakpc</a>);

  // Undo and redo all breakpoints. This is needed to bracket disassembly and
  // execution to skip past breakpoints when run from the debugger.
  <span class="d">void UndoBreakpoints()</span>;
  <span class="d">void RedoBreakpoints()</span>;
};

<span class="d">MipsDebugger::MipsDebugger(Simulator* sim) {
  sim_ = sim;
}</span>


<span class="d">MipsDebugger::~MipsDebugger() {
}</span>


<span class="d">#ifdef GENERATED_CODE_COVERAGE</span>
<a id='9553' tid='9554', class="m">static</a> <a id='9555' tid='9556', class="m">FILE</a><a id='9557' tid='9558', class="m">*</a> <a id='9559' tid='9560', class="m">coverage_log</a> = <a id='9561' tid='9562', class="m">NULL</a>;


<a id='9509' tid='9510', class="m">static</a> <a id='9511' tid='9512', class="m">void</a> <a id='9513' tid='9514', class="m">InitializeCoverage</a>() {
  <a id='9515' tid='9516', class="m">char</a><a id='9517' tid='9518', class="m">*</a> <a id='9519' tid='9520', class="m">file_name</a> = <a id='9521' tid='9522', class="m">getenv</a>(<a id='9523' tid='9524', class="m">&quot;V8_GENERATED_CODE_COVERAGE_LOG&quot;</a>);
  <a id='9525' tid='9526', class="m">if</a> (<a id='9527' tid='9528', class="m">file_name</a> <a id='9529' tid='9530', class="m">!=</a> <a id='9531' tid='9532', class="m">NULL</a>) {
    <a id='9533' tid='9534', class="m">coverage_log</a> <a id='9535' tid='9536', class="m">=</a> <a id='9537' tid='9538', class="m">fopen</a>(<a id='9539' tid='9540', class="m">file_name</a>, <a id='9541' tid='9542', class="m">&quot;aw+&quot;</a>);
  }
}


<a id='9443' tid='9444', class="m">void</a> <span class="d">MipsDebugger::Stop</span>(<a id='9445' tid='9446', class="m">Instruction</a><a id='9447' tid='9448', class="m">*</a> <a id='9449' tid='9450', class="m">instr</a>) {
  // Get the stop code.
  <span class="d">uint32_t code = instr-&gt;Bits(25, 6);</span>
  // Retrieve the encoded address, which comes just after this stop.
  <span class="d">char** msg_address =
    reinterpret_cast&lt;char**&gt;(sim_-&gt;get_pc() + Instr::kInstrSize);</span>
  <a id='9489' tid='9490', class="m">char</a><a id='9491' tid='9492', class="m">*</a> <a id='9493' tid='9494', class="m">msg</a> = <a id='9495' tid='9496', class="m">*</a><a id='9497' tid='9498', class="m">msg_address</a>;
  <span class="d">ASSERT(msg != NULL);</span>

  // Update this stop description.
  <span class="d">if</span> <span class="d">(!watched_stops[code].desc)</span> {
    <a id='9479' tid='9480', class="m">watched_stops</a>[<a id='9481' tid='9482', class="m">code</a>].<a id='9483' tid='9484', class="m">desc</a> <a id='9485' tid='9486', class="m">=</a> <a id='9487' tid='9488', class="m">msg</a>;
  }

  <span class="d">if (strlen(msg) &gt; 0) {
    if (coverage_log != NULL) {
      fprintf(coverage_log, &quot;%s\n&quot;, str);
      fflush(coverage_log);
    }
    // Overwrite the instruction and address with nops.
    instr-&gt;SetInstructionBits(kNopInstr);
    reinterpret_cast&lt;Instr*&gt;(msg_address)-&gt;SetInstructionBits(kNopInstr);
  }</span>
  <span class="d">sim_-&gt;set_pc(sim_-&gt;get_pc() + 2 * Instruction::kInstructionSize);</span>
}


<span class="d">#else</span>  // GENERATED_CODE_COVERAGE

<span class="d">#define UNSUPPORTED() printf(&quot;Unsupported instruction.\n&quot;);</span>

<span class="d">static void InitializeCoverage() {}</span>


<a id='9405' tid='9406', class="m">void</a> <span class="d">MipsDebugger::Stop</span>(<a id='9407' tid='9408', class="m">Instruction</a><a id='9409' tid='9410', class="m">*</a> <a id='9411' tid='9412', class="m">instr</a>) {
  // Get the stop code.
  <span class="d">uint32_t code = instr-&gt;Bits(25, 6);</span>
  // Retrieve the encoded address, which comes just after this stop.
  <a id='9451' tid='9452', class="m">char</a><a id='9453' tid='9454', class="m">*</a> <a id='9455' tid='9456', class="m">msg</a> = <a id='9457' tid='9458', class="m">*</a><a id='9459' tid='9460', class="m">reinterpret_cast</a>&lt;<a id='9461' tid='9462', class="m">char</a><a id='9463' tid='9464', class="m">*</a><a id='9465' tid='9466', class="m">*</a>&gt;(<a id='9467' tid='9468', class="m">sim_</a>-&gt;<a id='9469' tid='9470', class="m">get_pc</a>() <a id='9471' tid='9472', class="m">+</a>
      <a id='9473' tid='9474', class="m">Instruction</a><a id='9475' tid='9476', class="m">::</a><a id='9477' tid='9478', class="m">kInstrSize</a>);
  // Update this stop description.
  <a id='9381' tid='9382', class="m">if</a> (<a id='9383' tid='9384', class="m">!</a><a id='9385' tid='9386', class="m">sim_</a>-&gt;<a id='9387' tid='9388', class="m">watched_stops</a>[<a id='9389' tid='9390', class="m">code</a>].<a id='9391' tid='9392', class="m">desc</a>) {
    <a id='9393' tid='9394', class="m">sim_</a>-&gt;<a id='9395' tid='9396', class="m">watched_stops</a>[<a id='9397' tid='9398', class="m">code</a>].<a id='9399' tid='9400', class="m">desc</a> <a id='9401' tid='9402', class="m">=</a> <a id='9403' tid='9404', class="m">msg</a>;
  }
  <span class="d">PrintF(&quot;Simulator hit %s (%u)\n&quot;, msg, code);</span>
  <a id='9423' tid='9424', class="m">sim_</a>-&gt;<a id='9425' tid='9426', class="m">set_pc</a>(<a id='9427' tid='9428', class="m">sim_</a>-&gt;<a id='9429' tid='9430', class="m">get_pc</a>() <a id='9431' tid='9432', class="m">+</a> <a id='9433' tid='9434', class="m">2</a> <a id='9435' tid='9436', class="m">*</a> <a id='9437' tid='9438', class="m">Instruction</a><a id='9439' tid='9440', class="m">::</a><a id='9441' tid='9442', class="m">kInstrSize</a>);
  <span class="d">Debug();</span>
}
<span class="d">#endif</span>  // GENERATED_CODE_COVERAGE


<a id='9361' tid='9362', class="m">int32_t</a> <span class="d">MipsDebugger::GetRegisterValue</span>(<a id='9363' tid='9364', class="m">int</a> <a id='9365' tid='9366', class="m">regnum</a>) {
  <span class="d">if</span> <span class="d">(regnum == kNumSimuRegisters)</span> <span class="d">{
    return sim_-&gt;get_pc();
  }</span> <a id='9413' tid='9414', class="m">else</a> {
    <a id='9415' tid='9416', class="m">return</a> <a id='9417' tid='9418', class="m">sim_</a>-&gt;<a id='9419' tid='9420', class="m">get_register</a>(<a id='9421' tid='9422', class="m">regnum</a>);
  }
}


<span class="d">int32_t MipsDebugger::GetFPURegisterValueInt(int regnum) {
  if (regnum == kNumFPURegisters) {
    return sim_-&gt;get_pc();
  } else {
    return sim_-&gt;get_fpu_register(regnum);
  }
}</span>


<span class="d">int64_t MipsDebugger::GetFPURegisterValueLong(int regnum) {
  if (regnum == kNumFPURegisters) {
    return sim_-&gt;get_pc();
  } else {
    return sim_-&gt;get_fpu_register_long(regnum);
  }
}</span>


<span class="d">float MipsDebugger::GetFPURegisterValueFloat(int regnum) {
  if (regnum == kNumFPURegisters) {
    return sim_-&gt;get_pc();
  } else {
    return sim_-&gt;get_fpu_register_float(regnum);
  }
}</span>


<span class="d">double MipsDebugger::GetFPURegisterValueDouble(int regnum) {
  if (regnum == kNumFPURegisters) {
    return sim_-&gt;get_pc();
  } else {
    return sim_-&gt;get_fpu_register_double(regnum);
  }
}</span>


<span class="d">bool</span> <span class="d">MipsDebugger::GetValue</span>(<a id='9367' tid='9368', class="m">const</a> <a id='9369' tid='9370', class="m">char</a><a id='9371' tid='9372', class="m">*</a> <a id='9373' tid='9374', class="m">desc</a>, <a id='9375' tid='9376', class="m">int32_t</a><a id='9377' tid='9378', class="m">*</a> <a id='9379' tid='9380', class="m">value</a>) {
  <a id='9313' tid='9314', class="m">int</a> <a id='9315' tid='9316', class="m">regnum</a> = <a id='9317' tid='9318', class="m">Registers</a><a id='9319' tid='9320', class="m">::</a><a id='9321' tid='9322', class="m">Number</a>(<a id='9323' tid='9324', class="m">desc</a>);
  <span class="d">int fpuregnum = FPURegisters::Number(desc);</span>

  <span class="d">if</span> <span class="d">(regnum != kInvalidRegister)</span> {
    <a id='9299' tid='9300', class="m">*</a><a id='9301' tid='9302', class="m">value</a> <a id='9303' tid='9304', class="m">=</a> <a id='9305' tid='9306', class="m">GetRegisterValue</a>(<a id='9307' tid='9308', class="m">regnum</a>);
    <a id='9309' tid='9310', class="m">return</a> <a id='9311' tid='9312', class="m">true</a>;
  } <span class="d">else</span> <span class="d">if</span> <span class="d">(fpuregnum != kInvalidFPURegister)</span> <span class="d">{
    *value = GetFPURegisterValueInt(fpuregnum);
    return true;
  }</span> <a id='9237' tid='9238', class="m">else</a> <span class="d">if</span> (<a id='9239' tid='9240', class="m">strncmp</a>(<a id='9241' tid='9242', class="m">desc</a>, <a id='9243' tid='9244', class="m">&quot;0x&quot;</a>, <a id='9245' tid='9246', class="m">2</a>) <a id='9247' tid='9248', class="m">==</a> <a id='9249' tid='9250', class="m">0</a>) <span class="d">{
    return SScanF(desc, &quot;%x&quot;, reinterpret_cast&lt;uint32_t*&gt;(value)) == 1;
  }</span> <span class="d">else {
    return SScanF(desc, &quot;%i&quot;, value) == 1;
  }</span>
  <span class="d">return false;</span>
}


<a id='9251' tid='9252', class="m">bool</a> <span class="d">MipsDebugger::SetBreakpoint</span>(<a id='9253' tid='9254', class="m">Instruction</a><a id='9255' tid='9256', class="m">*</a> <a id='9257' tid='9258', class="m">breakpc</a>) {
  // Check if a breakpoint can be set. If not return without any side-effects.
  <a id='9325' tid='9326', class="m">if</a> (<a id='9327' tid='9328', class="m">sim_</a>-&gt;<a id='9329' tid='9330', class="m">break_pc_</a> <a id='9331' tid='9332', class="m">!=</a> <a id='9333' tid='9334', class="m">NULL</a>) {
    <a id='9335' tid='9336', class="m">return</a> <a id='9337' tid='9338', class="m">false</a>;
  }

  // Set the breakpoint.
  <a id='9339' tid='9340', class="m">sim_</a>-&gt;<a id='9341' tid='9342', class="m">break_pc_</a> <a id='9343' tid='9344', class="m">=</a> <a id='9345' tid='9346', class="m">breakpc</a>;
  <a id='9347' tid='9348', class="m">sim_</a>-&gt;<a id='9349' tid='9350', class="m">break_instr_</a> <a id='9351' tid='9352', class="m">=</a> <a id='9353' tid='9354', class="m">breakpc</a>-&gt;<a id='9355' tid='9356', class="m">InstructionBits</a>();
  // Not setting the breakpoint instruction in the code itself. It will be set
  // when the debugger shell continues.
  <a id='9357' tid='9358', class="m">return</a> <a id='9359' tid='9360', class="m">true</a>;
}


<a id='9209' tid='9210', class="m">bool</a> <span class="d">MipsDebugger::DeleteBreakpoint</span>(<a id='9211' tid='9212', class="m">Instruction</a><a id='9213' tid='9214', class="m">*</a> <a id='9215' tid='9216', class="m">breakpc</a>) {
  <a id='9259' tid='9260', class="m">if</a> (<a id='9261' tid='9262', class="m">sim_</a>-&gt;<a id='9263' tid='9264', class="m">break_pc_</a> <a id='9265' tid='9266', class="m">!=</a> <a id='9267' tid='9268', class="m">NULL</a>) {
    <a id='9269' tid='9270', class="m">sim_</a>-&gt;<a id='9271' tid='9272', class="m">break_pc_</a>-&gt;<a id='9273' tid='9274', class="m">SetInstructionBits</a>(<a id='9275' tid='9276', class="m">sim_</a>-&gt;<a id='9277' tid='9278', class="m">break_instr_</a>);
  }

  <a id='9279' tid='9280', class="m">sim_</a>-&gt;<a id='9281' tid='9282', class="m">break_pc_</a> <a id='9283' tid='9284', class="m">=</a> <a id='9285' tid='9286', class="m">NULL</a>;
  <a id='9287' tid='9288', class="m">sim_</a>-&gt;<a id='9289' tid='9290', class="m">break_instr_</a> <a id='9291' tid='9292', class="m">=</a> <a id='9293' tid='9294', class="m">0</a>;
  <a id='9295' tid='9296', class="m">return</a> <a id='9297' tid='9298', class="m">true</a>;
}


<span class="d">void</span> <span class="d">MipsDebugger::UndoBreakpoints</span><span class="d">()</span> {
  <a id='9217' tid='9218', class="m">if</a> (<a id='9219' tid='9220', class="m">sim_</a>-&gt;<a id='9221' tid='9222', class="m">break_pc_</a> <a id='9223' tid='9224', class="m">!=</a> <a id='9225' tid='9226', class="m">NULL</a>) {
    <a id='9227' tid='9228', class="m">sim_</a>-&gt;<a id='9229' tid='9230', class="m">break_pc_</a>-&gt;<a id='9231' tid='9232', class="m">SetInstructionBits</a>(<a id='9233' tid='9234', class="m">sim_</a>-&gt;<a id='9235' tid='9236', class="m">break_instr_</a>);
  }
}


<span class="d">void</span> <span class="d">MipsDebugger::RedoBreakpoints</span><span class="d">()</span> {
  <a id='9191' tid='9192', class="m">if</a> (<a id='9193' tid='9194', class="m">sim_</a>-&gt;<a id='9195' tid='9196', class="m">break_pc_</a> <a id='9197' tid='9198', class="m">!=</a> <a id='9199' tid='9200', class="m">NULL</a>) {
    <a id='9201' tid='9202', class="m">sim_</a>-&gt;<a id='9203' tid='9204', class="m">break_pc_</a>-&gt;<a id='9205' tid='9206', class="m">SetInstructionBits</a>(<a id='9207' tid='9208', class="m">kBreakpointInstr</a>);
  }
}


<span class="d">void MipsDebugger::PrintAllRegs() {
#define REG_INFO(n) Registers::Name(n), GetRegisterValue(n), GetRegisterValue(n)

  PrintF(&quot;\n&quot;);
  // at, v0, a0.
  PrintF(&quot;%3s: 0x%08x %10d\t%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
         REG_INFO(1), REG_INFO(2), REG_INFO(4));
  // v1, a1.
  PrintF(&quot;%26s\t%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
         &quot;&quot;, REG_INFO(3), REG_INFO(5));
  // a2.
  PrintF(&quot;%26s\t%26s\t%3s: 0x%08x %10d\n&quot;, &quot;&quot;, &quot;&quot;, REG_INFO(6));
  // a3.
  PrintF(&quot;%26s\t%26s\t%3s: 0x%08x %10d\n&quot;, &quot;&quot;, &quot;&quot;, REG_INFO(7));
  PrintF(&quot;\n&quot;);
  // t0-t7, s0-s7
  for (int i = 0; i &lt; 8; i++) {
    PrintF(&quot;%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
           REG_INFO(8+i), REG_INFO(16+i));
  }