
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<LINK href="diff-s.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="nav-div.js"></script>
</head>
<body>
<div id="left" class="src">
<pre>
<a id='leftstart' tid='rightstart'></a>
// Copyright 2011 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#<a id='9613' tid='9614', class="m">include</a> <a id='9615' tid='9616', class="m">&lt;</a><a id='9617' tid='9618', class="m">stdlib</a><a id='9619' tid='9620', class="m">.</a><a id='9621' tid='9622', class="m">h</a><a id='9623' tid='9624', class="m">&gt;</a>
#<a id='9601' tid='9602', class="m">include</a> <a id='9603' tid='9604', class="m">&lt;</a><a id='9605' tid='9606', class="m">math</a><a id='9607' tid='9608', class="m">.</a><a id='9609' tid='9610', class="m">h</a><a id='9611' tid='9612', class="m">&gt;</a>
<span class="d">#include &lt;limits.h&gt;</span>
<span class="d">#include &lt;cstdarg&gt;</span>
<span class="d">#include &quot;v8.h&quot;</span>

<span class="d">#if defined(V8_TARGET_ARCH_MIPS)</span>

<span class="d">#include &quot;disasm.h&quot;</span>
<span class="d">#include &quot;assembler.h&quot;</span>
<span class="d">#include &quot;globals.h&quot;</span>    // Need the BitCast.
<span class="d">#include &quot;mips/constants-mips.h&quot;</span>
<span class="d">#include &quot;mips/simulator-mips.h&quot;</span>


// Only build the simulator if not compiling for real MIPS hardware.
#<a id='9591' tid='9592', class="m">if</a> <a id='9593' tid='9594', class="m">defined</a><a id='9595' tid='9596', class="m">(</a><a id='9597' tid='9598', class="m">USE_SIMULATOR</a><a id='9599' tid='9600', class="m">)</a>

namespace <span class="d">v8</span> {
namespace <span class="d">internal</span> {

// Utils functions.
<span class="d">bool HaveSameSign(int32_t a, int32_t b) {
  return ((a ^ b) &gt;= 0);
}</span>


<span class="d">uint32_t get_fcsr_condition_bit(uint32_t cc) {
  if (cc == 0) {
    return 23;
  } else {
    return 24 + cc;
  }
}</span>


// This macro provides a platform independent use of sscanf. The reason for
// SScanF not being implemented in a platform independent was through
// ::v8::internal::OS in the same way as SNPrintF is that the Windows C Run-Time
// Library does not provide vsscanf.
<span class="d">#define SScanF sscanf</span>  // NOLINT

// The MipsDebugger class is used by the simulator while debugging simulated
// code.
<span class="d">class</span> <span class="d">MipsDebugger</span> {
 <span class="d">public:</span>
  <span class="d">explicit MipsDebugger(Simulator* sim)</span>;
  <span class="d">~MipsDebugger();</span>

  <a id='9581' tid='9582', class="m">void</a> <a id='9583' tid='9584', class="m">Stop</a>(<a id='9585' tid='9586', class="m">Instruction</a><a id='9587' tid='9588', class="m">*</a> <a id='9589' tid='9590', class="m">instr</a>);
  <span class="d">void Debug()</span>;
  // Print all registers with a nice formatting.
  <span class="d">void PrintAllRegs()</span>;
  <span class="d">void PrintAllRegsIncludingFPU()</span>;

 <span class="d">private:</span>
  // We set the breakpoint code to 0xfffff to easily recognize it.
  <span class="d">static const Instr kBreakpointInstr = SPECIAL | BREAK | 0xfffff &lt;&lt; 6;</span>
  <span class="d">static const Instr kNopInstr =  0x0;</span>

  <span class="d">Simulator* sim_;</span>

  <span class="d">int32_t GetRegisterValue(int regnum)</span>;
  <span class="d">int32_t GetFPURegisterValueInt(int regnum)</span>;
  <span class="d">int64_t GetFPURegisterValueLong(int regnum)</span>;
  <span class="d">float GetFPURegisterValueFloat(int regnum)</span>;
  <span class="d">double GetFPURegisterValueDouble(int regnum)</span>;
  <a id='9563' tid='9564', class="m">bool</a> <a id='9565' tid='9566', class="m">GetValue</a>(<a id='9567' tid='9568', class="m">const</a> <a id='9569' tid='9570', class="m">char</a><a id='9571' tid='9572', class="m">*</a> <a id='9573' tid='9574', class="m">desc</a>, <a id='9575' tid='9576', class="m">int32_t</a><a id='9577' tid='9578', class="m">*</a> <a id='9579' tid='9580', class="m">value</a>);

  // Set or delete a breakpoint. Returns true if successful.
  <a id='9543' tid='9544', class="m">bool</a> <a id='9545' tid='9546', class="m">SetBreakpoint</a>(<a id='9547' tid='9548', class="m">Instruction</a><a id='9549' tid='9550', class="m">*</a> <a id='9551' tid='9552', class="m">breakpc</a>);
  <a id='9499' tid='9500', class="m">bool</a> <a id='9501' tid='9502', class="m">DeleteBreakpoint</a>(<a id='9503' tid='9504', class="m">Instruction</a><a id='9505' tid='9506', class="m">*</a> <a id='9507' tid='9508', class="m">breakpc</a>);

  // Undo and redo all breakpoints. This is needed to bracket disassembly and
  // execution to skip past breakpoints when run from the debugger.
  <span class="d">void UndoBreakpoints()</span>;
  <span class="d">void RedoBreakpoints()</span>;
};

<span class="d">MipsDebugger::MipsDebugger(Simulator* sim) {
  sim_ = sim;
}</span>


<span class="d">MipsDebugger::~MipsDebugger() {
}</span>


<span class="d">#ifdef GENERATED_CODE_COVERAGE</span>
<a id='9553' tid='9554', class="m">static</a> <a id='9555' tid='9556', class="m">FILE</a><a id='9557' tid='9558', class="m">*</a> <a id='9559' tid='9560', class="m">coverage_log</a> = <a id='9561' tid='9562', class="m">NULL</a>;


<a id='9509' tid='9510', class="m">static</a> <a id='9511' tid='9512', class="m">void</a> <a id='9513' tid='9514', class="m">InitializeCoverage</a>() {
  <a id='9515' tid='9516', class="m">char</a><a id='9517' tid='9518', class="m">*</a> <a id='9519' tid='9520', class="m">file_name</a> = <a id='9521' tid='9522', class="m">getenv</a>(<a id='9523' tid='9524', class="m">&quot;V8_GENERATED_CODE_COVERAGE_LOG&quot;</a>);
  <a id='9525' tid='9526', class="m">if</a> (<a id='9527' tid='9528', class="m">file_name</a> <a id='9529' tid='9530', class="m">!=</a> <a id='9531' tid='9532', class="m">NULL</a>) {
    <a id='9533' tid='9534', class="m">coverage_log</a> <a id='9535' tid='9536', class="m">=</a> <a id='9537' tid='9538', class="m">fopen</a>(<a id='9539' tid='9540', class="m">file_name</a>, <a id='9541' tid='9542', class="m">&quot;aw+&quot;</a>);
  }
}


<a id='9443' tid='9444', class="m">void</a> <span class="d">MipsDebugger::Stop</span>(<a id='9445' tid='9446', class="m">Instruction</a><a id='9447' tid='9448', class="m">*</a> <a id='9449' tid='9450', class="m">instr</a>) {
  // Get the stop code.
  <span class="d">uint32_t code = instr-&gt;Bits(25, 6);</span>
  // Retrieve the encoded address, which comes just after this stop.
  <span class="d">char** msg_address =
    reinterpret_cast&lt;char**&gt;(sim_-&gt;get_pc() + Instr::kInstrSize);</span>
  <a id='9489' tid='9490', class="m">char</a><a id='9491' tid='9492', class="m">*</a> <a id='9493' tid='9494', class="m">msg</a> = <a id='9495' tid='9496', class="m">*</a><a id='9497' tid='9498', class="m">msg_address</a>;
  <span class="d">ASSERT(msg != NULL);</span>

  // Update this stop description.
  <span class="d">if</span> <span class="d">(!watched_stops[code].desc)</span> {
    <a id='9479' tid='9480', class="m">watched_stops</a>[<a id='9481' tid='9482', class="m">code</a>].<a id='9483' tid='9484', class="m">desc</a> <a id='9485' tid='9486', class="m">=</a> <a id='9487' tid='9488', class="m">msg</a>;
  }

  <span class="d">if (strlen(msg) &gt; 0) {
    if (coverage_log != NULL) {
      fprintf(coverage_log, &quot;%s\n&quot;, str);
      fflush(coverage_log);
    }
    // Overwrite the instruction and address with nops.
    instr-&gt;SetInstructionBits(kNopInstr);
    reinterpret_cast&lt;Instr*&gt;(msg_address)-&gt;SetInstructionBits(kNopInstr);
  }</span>
  <span class="d">sim_-&gt;set_pc(sim_-&gt;get_pc() + 2 * Instruction::kInstructionSize);</span>
}


<span class="d">#else</span>  // GENERATED_CODE_COVERAGE

<span class="d">#define UNSUPPORTED() printf(&quot;Unsupported instruction.\n&quot;);</span>

<span class="d">static void InitializeCoverage() {}</span>


<a id='9405' tid='9406', class="m">void</a> <span class="d">MipsDebugger::Stop</span>(<a id='9407' tid='9408', class="m">Instruction</a><a id='9409' tid='9410', class="m">*</a> <a id='9411' tid='9412', class="m">instr</a>) {
  // Get the stop code.
  <span class="d">uint32_t code = instr-&gt;Bits(25, 6);</span>
  // Retrieve the encoded address, which comes just after this stop.
  <a id='9451' tid='9452', class="m">char</a><a id='9453' tid='9454', class="m">*</a> <a id='9455' tid='9456', class="m">msg</a> = <a id='9457' tid='9458', class="m">*</a><a id='9459' tid='9460', class="m">reinterpret_cast</a>&lt;<a id='9461' tid='9462', class="m">char</a><a id='9463' tid='9464', class="m">*</a><a id='9465' tid='9466', class="m">*</a>&gt;(<a id='9467' tid='9468', class="m">sim_</a>-&gt;<a id='9469' tid='9470', class="m">get_pc</a>() <a id='9471' tid='9472', class="m">+</a>
      <a id='9473' tid='9474', class="m">Instruction</a><a id='9475' tid='9476', class="m">::</a><a id='9477' tid='9478', class="m">kInstrSize</a>);
  // Update this stop description.
  <a id='9381' tid='9382', class="m">if</a> (<a id='9383' tid='9384', class="m">!</a><a id='9385' tid='9386', class="m">sim_</a>-&gt;<a id='9387' tid='9388', class="m">watched_stops</a>[<a id='9389' tid='9390', class="m">code</a>].<a id='9391' tid='9392', class="m">desc</a>) {
    <a id='9393' tid='9394', class="m">sim_</a>-&gt;<a id='9395' tid='9396', class="m">watched_stops</a>[<a id='9397' tid='9398', class="m">code</a>].<a id='9399' tid='9400', class="m">desc</a> <a id='9401' tid='9402', class="m">=</a> <a id='9403' tid='9404', class="m">msg</a>;
  }
  <span class="d">PrintF(&quot;Simulator hit %s (%u)\n&quot;, msg, code);</span>
  <a id='9423' tid='9424', class="m">sim_</a>-&gt;<a id='9425' tid='9426', class="m">set_pc</a>(<a id='9427' tid='9428', class="m">sim_</a>-&gt;<a id='9429' tid='9430', class="m">get_pc</a>() <a id='9431' tid='9432', class="m">+</a> <a id='9433' tid='9434', class="m">2</a> <a id='9435' tid='9436', class="m">*</a> <a id='9437' tid='9438', class="m">Instruction</a><a id='9439' tid='9440', class="m">::</a><a id='9441' tid='9442', class="m">kInstrSize</a>);
  <span class="d">Debug();</span>
}
<span class="d">#endif</span>  // GENERATED_CODE_COVERAGE


<a id='9361' tid='9362', class="m">int32_t</a> <span class="d">MipsDebugger::GetRegisterValue</span>(<a id='9363' tid='9364', class="m">int</a> <a id='9365' tid='9366', class="m">regnum</a>) {
  <span class="d">if</span> <span class="d">(regnum == kNumSimuRegisters)</span> <span class="d">{
    return sim_-&gt;get_pc();
  }</span> <a id='9413' tid='9414', class="m">else</a> {
    <a id='9415' tid='9416', class="m">return</a> <a id='9417' tid='9418', class="m">sim_</a>-&gt;<a id='9419' tid='9420', class="m">get_register</a>(<a id='9421' tid='9422', class="m">regnum</a>);
  }
}


<span class="d">int32_t MipsDebugger::GetFPURegisterValueInt(int regnum) {
  if (regnum == kNumFPURegisters) {
    return sim_-&gt;get_pc();
  } else {
    return sim_-&gt;get_fpu_register(regnum);
  }
}</span>


<span class="d">int64_t MipsDebugger::GetFPURegisterValueLong(int regnum) {
  if (regnum == kNumFPURegisters) {
    return sim_-&gt;get_pc();
  } else {
    return sim_-&gt;get_fpu_register_long(regnum);
  }
}</span>


<span class="d">float MipsDebugger::GetFPURegisterValueFloat(int regnum) {
  if (regnum == kNumFPURegisters) {
    return sim_-&gt;get_pc();
  } else {
    return sim_-&gt;get_fpu_register_float(regnum);
  }
}</span>


<span class="d">double MipsDebugger::GetFPURegisterValueDouble(int regnum) {
  if (regnum == kNumFPURegisters) {
    return sim_-&gt;get_pc();
  } else {
    return sim_-&gt;get_fpu_register_double(regnum);
  }
}</span>


<span class="d">bool</span> <span class="d">MipsDebugger::GetValue</span>(<a id='9367' tid='9368', class="m">const</a> <a id='9369' tid='9370', class="m">char</a><a id='9371' tid='9372', class="m">*</a> <a id='9373' tid='9374', class="m">desc</a>, <a id='9375' tid='9376', class="m">int32_t</a><a id='9377' tid='9378', class="m">*</a> <a id='9379' tid='9380', class="m">value</a>) {
  <a id='9313' tid='9314', class="m">int</a> <a id='9315' tid='9316', class="m">regnum</a> = <a id='9317' tid='9318', class="m">Registers</a><a id='9319' tid='9320', class="m">::</a><a id='9321' tid='9322', class="m">Number</a>(<a id='9323' tid='9324', class="m">desc</a>);
  <span class="d">int fpuregnum = FPURegisters::Number(desc);</span>

  <span class="d">if</span> <span class="d">(regnum != kInvalidRegister)</span> {
    <a id='9299' tid='9300', class="m">*</a><a id='9301' tid='9302', class="m">value</a> <a id='9303' tid='9304', class="m">=</a> <a id='9305' tid='9306', class="m">GetRegisterValue</a>(<a id='9307' tid='9308', class="m">regnum</a>);
    <a id='9309' tid='9310', class="m">return</a> <a id='9311' tid='9312', class="m">true</a>;
  } <span class="d">else</span> <span class="d">if</span> <span class="d">(fpuregnum != kInvalidFPURegister)</span> <span class="d">{
    *value = GetFPURegisterValueInt(fpuregnum);
    return true;
  }</span> <a id='9237' tid='9238', class="m">else</a> <span class="d">if</span> (<a id='9239' tid='9240', class="m">strncmp</a>(<a id='9241' tid='9242', class="m">desc</a>, <a id='9243' tid='9244', class="m">&quot;0x&quot;</a>, <a id='9245' tid='9246', class="m">2</a>) <a id='9247' tid='9248', class="m">==</a> <a id='9249' tid='9250', class="m">0</a>) <span class="d">{
    return SScanF(desc, &quot;%x&quot;, reinterpret_cast&lt;uint32_t*&gt;(value)) == 1;
  }</span> <span class="d">else {
    return SScanF(desc, &quot;%i&quot;, value) == 1;
  }</span>
  <span class="d">return false;</span>
}


<a id='9251' tid='9252', class="m">bool</a> <span class="d">MipsDebugger::SetBreakpoint</span>(<a id='9253' tid='9254', class="m">Instruction</a><a id='9255' tid='9256', class="m">*</a> <a id='9257' tid='9258', class="m">breakpc</a>) {
  // Check if a breakpoint can be set. If not return without any side-effects.
  <a id='9325' tid='9326', class="m">if</a> (<a id='9327' tid='9328', class="m">sim_</a>-&gt;<a id='9329' tid='9330', class="m">break_pc_</a> <a id='9331' tid='9332', class="m">!=</a> <a id='9333' tid='9334', class="m">NULL</a>) {
    <a id='9335' tid='9336', class="m">return</a> <a id='9337' tid='9338', class="m">false</a>;
  }

  // Set the breakpoint.
  <a id='9339' tid='9340', class="m">sim_</a>-&gt;<a id='9341' tid='9342', class="m">break_pc_</a> <a id='9343' tid='9344', class="m">=</a> <a id='9345' tid='9346', class="m">breakpc</a>;
  <a id='9347' tid='9348', class="m">sim_</a>-&gt;<a id='9349' tid='9350', class="m">break_instr_</a> <a id='9351' tid='9352', class="m">=</a> <a id='9353' tid='9354', class="m">breakpc</a>-&gt;<a id='9355' tid='9356', class="m">InstructionBits</a>();
  // Not setting the breakpoint instruction in the code itself. It will be set
  // when the debugger shell continues.
  <a id='9357' tid='9358', class="m">return</a> <a id='9359' tid='9360', class="m">true</a>;
}


<a id='9209' tid='9210', class="m">bool</a> <span class="d">MipsDebugger::DeleteBreakpoint</span>(<a id='9211' tid='9212', class="m">Instruction</a><a id='9213' tid='9214', class="m">*</a> <a id='9215' tid='9216', class="m">breakpc</a>) {
  <a id='9259' tid='9260', class="m">if</a> (<a id='9261' tid='9262', class="m">sim_</a>-&gt;<a id='9263' tid='9264', class="m">break_pc_</a> <a id='9265' tid='9266', class="m">!=</a> <a id='9267' tid='9268', class="m">NULL</a>) {
    <a id='9269' tid='9270', class="m">sim_</a>-&gt;<a id='9271' tid='9272', class="m">break_pc_</a>-&gt;<a id='9273' tid='9274', class="m">SetInstructionBits</a>(<a id='9275' tid='9276', class="m">sim_</a>-&gt;<a id='9277' tid='9278', class="m">break_instr_</a>);
  }

  <a id='9279' tid='9280', class="m">sim_</a>-&gt;<a id='9281' tid='9282', class="m">break_pc_</a> <a id='9283' tid='9284', class="m">=</a> <a id='9285' tid='9286', class="m">NULL</a>;
  <a id='9287' tid='9288', class="m">sim_</a>-&gt;<a id='9289' tid='9290', class="m">break_instr_</a> <a id='9291' tid='9292', class="m">=</a> <a id='9293' tid='9294', class="m">0</a>;
  <a id='9295' tid='9296', class="m">return</a> <a id='9297' tid='9298', class="m">true</a>;
}


<span class="d">void</span> <span class="d">MipsDebugger::UndoBreakpoints</span><span class="d">()</span> {
  <a id='9217' tid='9218', class="m">if</a> (<a id='9219' tid='9220', class="m">sim_</a>-&gt;<a id='9221' tid='9222', class="m">break_pc_</a> <a id='9223' tid='9224', class="m">!=</a> <a id='9225' tid='9226', class="m">NULL</a>) {
    <a id='9227' tid='9228', class="m">sim_</a>-&gt;<a id='9229' tid='9230', class="m">break_pc_</a>-&gt;<a id='9231' tid='9232', class="m">SetInstructionBits</a>(<a id='9233' tid='9234', class="m">sim_</a>-&gt;<a id='9235' tid='9236', class="m">break_instr_</a>);
  }
}


<span class="d">void</span> <span class="d">MipsDebugger::RedoBreakpoints</span><span class="d">()</span> {
  <a id='9191' tid='9192', class="m">if</a> (<a id='9193' tid='9194', class="m">sim_</a>-&gt;<a id='9195' tid='9196', class="m">break_pc_</a> <a id='9197' tid='9198', class="m">!=</a> <a id='9199' tid='9200', class="m">NULL</a>) {
    <a id='9201' tid='9202', class="m">sim_</a>-&gt;<a id='9203' tid='9204', class="m">break_pc_</a>-&gt;<a id='9205' tid='9206', class="m">SetInstructionBits</a>(<a id='9207' tid='9208', class="m">kBreakpointInstr</a>);
  }
}


<span class="d">void MipsDebugger::PrintAllRegs() {
#define REG_INFO(n) Registers::Name(n), GetRegisterValue(n), GetRegisterValue(n)

  PrintF(&quot;\n&quot;);
  // at, v0, a0.
  PrintF(&quot;%3s: 0x%08x %10d\t%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
         REG_INFO(1), REG_INFO(2), REG_INFO(4));
  // v1, a1.
  PrintF(&quot;%26s\t%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
         &quot;&quot;, REG_INFO(3), REG_INFO(5));
  // a2.
  PrintF(&quot;%26s\t%26s\t%3s: 0x%08x %10d\n&quot;, &quot;&quot;, &quot;&quot;, REG_INFO(6));
  // a3.
  PrintF(&quot;%26s\t%26s\t%3s: 0x%08x %10d\n&quot;, &quot;&quot;, &quot;&quot;, REG_INFO(7));
  PrintF(&quot;\n&quot;);
  // t0-t7, s0-s7
  for (int i = 0; i &lt; 8; i++) {
    PrintF(&quot;%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
           REG_INFO(8+i), REG_INFO(16+i));
  }
  PrintF(&quot;\n&quot;);
  // t8, k0, LO.
  PrintF(&quot;%3s: 0x%08x %10d\t%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
         REG_INFO(24), REG_INFO(26), REG_INFO(32));
  // t9, k1, HI.
  PrintF(&quot;%3s: 0x%08x %10d\t%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
         REG_INFO(25), REG_INFO(27), REG_INFO(33));
  // sp, fp, gp.
  PrintF(&quot;%3s: 0x%08x %10d\t%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
         REG_INFO(29), REG_INFO(30), REG_INFO(28));
  // pc.
  PrintF(&quot;%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
         REG_INFO(31), REG_INFO(34));

#undef REG_INFO
#undef FPU_REG_INFO
}</span>


<span class="d">void MipsDebugger::PrintAllRegsIncludingFPU() {
#define FPU_REG_INFO(n) FPURegisters::Name(n), FPURegisters::Name(n+1), \
        GetFPURegisterValueInt(n+1), \
        GetFPURegisterValueInt(n), \
                        GetFPURegisterValueDouble(n)

  PrintAllRegs();

  PrintF(&quot;\n\n&quot;);
  // f0, f1, f2, ... f31.
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(0) );
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(2) );
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(4) );
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(6) );
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(8) );
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(10));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(12));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(14));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(16));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(18));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(20));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(22));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(24));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(26));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(28));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(30));

#undef REG_INFO
#undef FPU_REG_INFO
}</span>


<span class="d">void</span> <span class="d">MipsDebugger::Debug</span><span class="d">()</span> {
  <a id='8965' tid='8966', class="m">intptr_t</a> <a id='8967' tid='8968', class="m">last_pc</a> = <a id='8969' tid='8970', class="m">-</a><a id='8971' tid='8972', class="m">1</a>;
  <a id='8973' tid='8974', class="m">bool</a> <a id='8975' tid='8976', class="m">done</a> = <a id='8977' tid='8978', class="m">false</a>;

#<a id='8979' tid='8980', class="m">define</a> <a id='8981' tid='8982', class="m">COMMAND_SIZE</a> <a id='8983' tid='8984', class="m">63</a>
#<a id='8985' tid='8986', class="m">define</a> <a id='8987' tid='8988', class="m">ARG_SIZE</a> <a id='8989' tid='8990', class="m">255</a>

#<a id='9177' tid='9178', class="m">define</a> <a id='9179' tid='9180', class="m">STR</a><a id='9181' tid='9182', class="m">(</a><a id='9183' tid='9184', class="m">a</a><a id='9185' tid='9186', class="m">)</a> <a id='9187' tid='9188', class="m">#</a><a id='9189' tid='9190', class="m">a</a>
#<a id='8991' tid='8992', class="m">define</a> <a id='8993' tid='8994', class="m">XSTR</a><a id='8995' tid='8996', class="m">(</a><a id='8997' tid='8998', class="m">a</a><a id='8999' tid='9000', class="m">)</a> <a id='9001' tid='9002', class="m">STR</a><a id='9003' tid='9004', class="m">(</a><a id='9005' tid='9006', class="m">a</a><a id='9007' tid='9008', class="m">)</a>

  <a id='9009' tid='9010', class="m">char</a> <a id='9011' tid='9012', class="m">cmd</a>[<a id='9013' tid='9014', class="m">COMMAND_SIZE</a> <a id='9015' tid='9016', class="m">+</a> <a id='9017' tid='9018', class="m">1</a>];
  <a id='9019' tid='9020', class="m">char</a> <a id='9021' tid='9022', class="m">arg1</a>[<a id='9023' tid='9024', class="m">ARG_SIZE</a> <a id='9025' tid='9026', class="m">+</a> <a id='9027' tid='9028', class="m">1</a>];
  <a id='9029' tid='9030', class="m">char</a> <a id='9031' tid='9032', class="m">arg2</a>[<a id='9033' tid='9034', class="m">ARG_SIZE</a> <a id='9035' tid='9036', class="m">+</a> <a id='9037' tid='9038', class="m">1</a>];
  <a id='9039' tid='9040', class="m">char</a><a id='9041' tid='9042', class="m">*</a> <a id='9043' tid='9044', class="m">argv</a>[<a id='9045' tid='9046', class="m">3</a>] = { <a id='9047' tid='9048', class="m">cmd</a>, <a id='9049' tid='9050', class="m">arg1</a>, <a id='9051' tid='9052', class="m">arg2</a> };

  // Make sure to have a proper terminating character if reaching the limit.
  <a id='9053' tid='9054', class="m">cmd</a>[<a id='9055' tid='9056', class="m">COMMAND_SIZE</a>] <a id='9057' tid='9058', class="m">=</a> <a id='9059' tid='9060', class="m">0</a>;
  <a id='9061' tid='9062', class="m">arg1</a>[<a id='9063' tid='9064', class="m">ARG_SIZE</a>] <a id='9065' tid='9066', class="m">=</a> <a id='9067' tid='9068', class="m">0</a>;
  <a id='9069' tid='9070', class="m">arg2</a>[<a id='9071' tid='9072', class="m">ARG_SIZE</a>] <a id='9073' tid='9074', class="m">=</a> <a id='9075' tid='9076', class="m">0</a>;

  // Undo all set breakpoints while running in the debugger shell. This will
  // make them invisible to all commands.
  <a id='9077' tid='9078', class="m">UndoBreakpoints</a>();

  <span class="d">while</span> <span class="d">(!done && (sim_-&gt;get_pc() != Simulator::end_sim_pc))</span> {
    <a id='9079' tid='9080', class="m">if</a> (<a id='9081' tid='9082', class="m">last_pc</a> <a id='9083' tid='9084', class="m">!=</a> <a id='9085' tid='9086', class="m">sim_</a>-&gt;<a id='9087' tid='9088', class="m">get_pc</a>()) {
      <a id='9099' tid='9100', class="m">disasm</a><a id='9101' tid='9102', class="m">::</a><a id='9103' tid='9104', class="m">NameConverter</a> <a id='9105' tid='9106', class="m">converter</a>;
      <a id='9089' tid='9090', class="m">disasm</a><a id='9091' tid='9092', class="m">::</a><a id='9093' tid='9094', class="m">Disassembler</a> <a id='9095' tid='9096', class="m">dasm</a>(<a id='9097' tid='9098', class="m">converter</a>);
      // Use a reasonably large buffer.
      <a id='9107' tid='9108', class="m">v8</a><a id='9109' tid='9110', class="m">::</a><a id='9111' tid='9112', class="m">internal</a><a id='9113' tid='9114', class="m">::</a><a id='9115' tid='9116', class="m">EmbeddedVector</a>&lt;<a id='9117' tid='9118', class="m">char</a>, <a id='9119' tid='9120', class="m">256</a>&gt; <a id='9121' tid='9122', class="m">buffer</a>;
      <a id='9123' tid='9124', class="m">dasm</a>.<a id='9125' tid='9126', class="m">InstructionDecode</a>(<a id='9127' tid='9128', class="m">buffer</a>,
                             <a id='9129' tid='9130', class="m">reinterpret_cast</a>&lt;<a id='9131' tid='9132', class="m">byte</a><a id='9133' tid='9134', class="m">*</a>&gt;(<a id='9135' tid='9136', class="m">sim_</a>-&gt;<a id='9137' tid='9138', class="m">get_pc</a>()));
      <a id='9139' tid='9140', class="m">PrintF</a>(<a id='9141' tid='9142', class="m">&quot;  0x%08x  %s\n&quot;</a>, <a id='9143' tid='9144', class="m">sim_</a>-&gt;<a id='9145' tid='9146', class="m">get_pc</a>(), <a id='9147' tid='9148', class="m">buffer</a>.<a id='9149' tid='9150', class="m">start</a>());
      <a id='9151' tid='9152', class="m">last_pc</a> <a id='9153' tid='9154', class="m">=</a> <a id='9155' tid='9156', class="m">sim_</a>-&gt;<a id='9157' tid='9158', class="m">get_pc</a>();
    }
    <a id='8115' tid='8116', class="m">char</a><a id='8117' tid='8118', class="m">*</a> <a id='8119' tid='8120', class="m">line</a> = <a id='8121' tid='8122', class="m">ReadLine</a>(<a id='8123' tid='8124', class="m">&quot;sim&gt; &quot;</a>);
    <a id='8125' tid='8126', class="m">if</a> (<a id='8127' tid='8128', class="m">line</a> <a id='8129' tid='8130', class="m">==</a> <a id='8131' tid='8132', class="m">NULL</a>) {
      <a id='8133' tid='8134', class="m">break</a>;
    } <a id='8135' tid='8136', class="m">else</a> {
      // Use sscanf to parse the individual parts of the command line. At the
      // moment no command expects more than two parameters.
      <a id='8137' tid='8138', class="m">int</a> <a id='8139' tid='8140', class="m">argc</a> = <a id='8141' tid='8142', class="m">SScanF</a>(<a id='8143' tid='8144', class="m">line</a>,
                        <a id='8145' tid='8146', class="m">&quot;%&quot;</a> <a id='8147' tid='8148', class="m">XSTR</a>(<a id='8149' tid='8150', class="m">COMMAND_SIZE</a>) <a id='8151' tid='8152', class="m">&quot;s &quot;</a>
                        <a id='8153' tid='8154', class="m">&quot;%&quot;</a> <a id='8155' tid='8156', class="m">XSTR</a>(<a id='8157' tid='8158', class="m">ARG_SIZE</a>) <a id='8159' tid='8160', class="m">&quot;s &quot;</a>
                        <a id='8161' tid='8162', class="m">&quot;%&quot;</a> <a id='8163' tid='8164', class="m">XSTR</a>(<a id='8165' tid='8166', class="m">ARG_SIZE</a>) <a id='8167' tid='8168', class="m">&quot;s&quot;</a>,
                        <a id='8169' tid='8170', class="m">cmd</a>, <a id='8171' tid='8172', class="m">arg1</a>, <a id='8173' tid='8174', class="m">arg2</a>);
      <a id='8175' tid='8176', class="m">if</a> ((<a id='8177' tid='8178', class="m">strcmp</a>(<a id='8179' tid='8180', class="m">cmd</a>, <a id='8181' tid='8182', class="m">&quot;si&quot;</a>) <a id='8183' tid='8184', class="m">==</a> <a id='8185' tid='8186', class="m">0</a>) <a id='8187' tid='8188', class="m">||</a> (<a id='8189' tid='8190', class="m">strcmp</a>(<a id='8191' tid='8192', class="m">cmd</a>, <a id='8193' tid='8194', class="m">&quot;stepi&quot;</a>) <a id='8195' tid='8196', class="m">==</a> <a id='8197' tid='8198', class="m">0</a>)) {
        <span class="d">Instruction* instr = reinterpret_cast&lt;Instruction*&gt;(sim_-&gt;get_pc());</span>
        <span class="d">if</span> <span class="d">(!(instr-&gt;IsTrap()) ||
            instr-&gt;InstructionBits() == rtCallRedirInstr)</span> {
          <a id='8199' tid='8200', class="m">sim_</a>-&gt;<a id='8201' tid='8202', class="m">InstructionDecode</a>(
              <a id='8203' tid='8204', class="m">reinterpret_cast</a>&lt;<a id='8205' tid='8206', class="m">Instruction</a><a id='8207' tid='8208', class="m">*</a>&gt;(<a id='8209' tid='8210', class="m">sim_</a>-&gt;<a id='8211' tid='8212', class="m">get_pc</a>()));
        } <span class="d">else</span> {
          // Allow si to jump over generated breakpoints.
          <span class="d">PrintF(&quot;/!\\ Jumping over generated breakpoint.\n&quot;);</span>
          <span class="d">sim_-&gt;set_pc</span>(<a id='8037' tid='8038', class="m">sim_</a>-&gt;<a id='8039' tid='8040', class="m">get_pc</a>() <a id='8041' tid='8042', class="m">+</a> <a id='8043' tid='8044', class="m">Instruction</a><a id='8045' tid='8046', class="m">::</a><a id='8047' tid='8048', class="m">kInstrSize</a>);
        }
      } <a id='8213' tid='8214', class="m">else</a> <a id='8215' tid='8216', class="m">if</a> ((<a id='8217' tid='8218', class="m">strcmp</a>(<a id='8219' tid='8220', class="m">cmd</a>, <a id='8221' tid='8222', class="m">&quot;c&quot;</a>) <a id='8223' tid='8224', class="m">==</a> <a id='8225' tid='8226', class="m">0</a>) <a id='8227' tid='8228', class="m">||</a> (<a id='8229' tid='8230', class="m">strcmp</a>(<a id='8231' tid='8232', class="m">cmd</a>, <a id='8233' tid='8234', class="m">&quot;cont&quot;</a>) <a id='8235' tid='8236', class="m">==</a> <a id='8237' tid='8238', class="m">0</a>)) {
        // Execute the one instruction we broke at with breakpoints disabled.
        <a id='8239' tid='8240', class="m">sim_</a>-&gt;<a id='8241' tid='8242', class="m">InstructionDecode</a>(<a id='8243' tid='8244', class="m">reinterpret_cast</a>&lt;<a id='8245' tid='8246', class="m">Instruction</a><a id='8247' tid='8248', class="m">*</a>&gt;(<a id='8249' tid='8250', class="m">sim_</a>-&gt;<a id='8251' tid='8252', class="m">get_pc</a>()));
        // Leave the debugger shell.
        <a id='8253' tid='8254', class="m">done</a> <a id='8255' tid='8256', class="m">=</a> <a id='8257' tid='8258', class="m">true</a>;
      } <a id='8259' tid='8260', class="m">else</a> <a id='8261' tid='8262', class="m">if</a> ((<a id='8263' tid='8264', class="m">strcmp</a>(<a id='8265' tid='8266', class="m">cmd</a>, <a id='8267' tid='8268', class="m">&quot;p&quot;</a>) <a id='8269' tid='8270', class="m">==</a> <a id='8271' tid='8272', class="m">0</a>) <a id='8273' tid='8274', class="m">||</a> (<a id='8275' tid='8276', class="m">strcmp</a>(<a id='8277' tid='8278', class="m">cmd</a>, <a id='8279' tid='8280', class="m">&quot;print&quot;</a>) <a id='8281' tid='8282', class="m">==</a> <a id='8283' tid='8284', class="m">0</a>)) {
        <span class="d">if</span> <span class="d">(argc == 2)</span> {
          <span class="d">int32_t value;</span>
          <span class="d">float fvalue;</span>
          <span class="d">if</span> (<a id='8285' tid='8286', class="m">strcmp</a>(<a id='8287' tid='8288', class="m">arg1</a>, <a id='8289' tid='8290', class="m">&quot;all&quot;</a>) <a id='8291' tid='8292', class="m">==</a> <a id='8293' tid='8294', class="m">0</a>) <span class="d">{
            PrintAllRegs();
          }</span> <a id='8049' tid='8050', class="m">else</a> <span class="d">if</span> <span class="d">(strcmp(arg1, &quot;allf&quot;) == 0)</span> <span class="d">{
            PrintAllRegsIncludingFPU();
          }</span> <span class="d">else</span> {
            <span class="d">int regnum = Registers::Number(arg1);</span>
            <span class="d">int fpuregnum = FPURegisters::Number(arg1);</span>

            <span class="d">if</span> <span class="d">(regnum != kInvalidRegister)</span> {
              <span class="d">value = GetRegisterValue(regnum);</span>
              <a id='8051' tid='8052', class="m">PrintF</a>(<a id='8053' tid='8054', class="m">&quot;%s: 0x%08x %d \n&quot;</a>, <a id='8055' tid='8056', class="m">arg1</a>, <a id='8057' tid='8058', class="m">value</a>, <a id='8059' tid='8060', class="m">value</a>);
            } <span class="d">else if (fpuregnum != kInvalidFPURegister) {
              if (fpuregnum % 2 == 1) {
                value = GetFPURegisterValueInt(fpuregnum);
                fvalue = GetFPURegisterValueFloat(fpuregnum);
                PrintF(&quot;%s: 0x%08x %11.4e\n&quot;, arg1, value, fvalue);
              } else {
                double dfvalue;
                int32_t lvalue1 = GetFPURegisterValueInt(fpuregnum);
                int32_t lvalue2 = GetFPURegisterValueInt(fpuregnum + 1);
                dfvalue = GetFPURegisterValueDouble(fpuregnum);
                PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;,
                       FPURegisters::Name(fpuregnum+1),
                       FPURegisters::Name(fpuregnum),
                       lvalue1,
                       lvalue2,
                       dfvalue);
              }
            } else {
              PrintF(&quot;%s unrecognized\n&quot;, arg1);
            }</span>
          }
        } <span class="d">else {
          if (argc == 3) {
            if (strcmp(arg2, &quot;single&quot;) == 0) {
              int32_t value;
              float fvalue;
              int fpuregnum = FPURegisters::Number(arg1);

              if (fpuregnum != kInvalidFPURegister) {
                value = GetFPURegisterValueInt(fpuregnum);
                fvalue = GetFPURegisterValueFloat(fpuregnum);
                PrintF(&quot;%s: 0x%08x %11.4e\n&quot;, arg1, value, fvalue);
              } else {
                PrintF(&quot;%s unrecognized\n&quot;, arg1);
              }
            } else {
              PrintF(&quot;print &lt;fpu register&gt; single\n&quot;);
            }
          } else {
            PrintF(&quot;print &lt;register&gt; or print &lt;fpu register&gt; single\n&quot;);
          }
        }</span>
      } <a id='8295' tid='8296', class="m">else</a> <a id='8297' tid='8298', class="m">if</a> ((<a id='8299' tid='8300', class="m">strcmp</a>(<a id='8301' tid='8302', class="m">cmd</a>, <a id='8303' tid='8304', class="m">&quot;po&quot;</a>) <a id='8305' tid='8306', class="m">==</a> <a id='8307' tid='8308', class="m">0</a>)
                 <a id='8309' tid='8310', class="m">||</a> (<a id='8311' tid='8312', class="m">strcmp</a>(<a id='8313' tid='8314', class="m">cmd</a>, <a id='8315' tid='8316', class="m">&quot;printobject&quot;</a>) <a id='8317' tid='8318', class="m">==</a> <a id='8319' tid='8320', class="m">0</a>)) {
        <a id='8321' tid='8322', class="m">if</a> (<a id='8323' tid='8324', class="m">argc</a> <a id='8325' tid='8326', class="m">==</a> <a id='8327' tid='8328', class="m">2</a>) {
          <a id='8329' tid='8330', class="m">int32_t</a> <a id='8331' tid='8332', class="m">value</a>;
          <a id='8333' tid='8334', class="m">if</a> (<a id='8335' tid='8336', class="m">GetValue</a>(<a id='8337' tid='8338', class="m">arg1</a>, <a id='8339' tid='8340', class="m">&</a><a id='8341' tid='8342', class="m">value</a>)) {
            <a id='8343' tid='8344', class="m">Object</a><a id='8345' tid='8346', class="m">*</a> <a id='8347' tid='8348', class="m">obj</a> = <a id='8349' tid='8350', class="m">reinterpret_cast</a>&lt;<a id='8351' tid='8352', class="m">Object</a><a id='8353' tid='8354', class="m">*</a>&gt;(<a id='8355' tid='8356', class="m">value</a>);
            <a id='8357' tid='8358', class="m">PrintF</a>(<a id='8359' tid='8360', class="m">&quot;%s: \n&quot;</a>, <a id='8361' tid='8362', class="m">arg1</a>);
#<a id='8363' tid='8364', class="m">ifdef</a> <a id='8365' tid='8366', class="m">DEBUG</a>
            <a id='8367' tid='8368', class="m">obj</a>-&gt;<a id='8369' tid='8370', class="m">PrintLn</a>();
#<a id='8371' tid='8372', class="m">else</a>
            <a id='8373' tid='8374', class="m">obj</a>-&gt;<a id='8375' tid='8376', class="m">ShortPrint</a>();
            <a id='8377' tid='8378', class="m">PrintF</a>(<a id='8379' tid='8380', class="m">&quot;\n&quot;</a>);
#<a id='8381' tid='8382', class="m">endif</a>
          } <a id='8383' tid='8384', class="m">else</a> {
            <a id='8385' tid='8386', class="m">PrintF</a>(<a id='8387' tid='8388', class="m">&quot;%s unrecognized\n&quot;</a>, <a id='8389' tid='8390', class="m">arg1</a>);
          }
        } <a id='8391' tid='8392', class="m">else</a> {
          <a id='8393' tid='8394', class="m">PrintF</a>(<a id='8395' tid='8396', class="m">&quot;printobject &lt;value&gt;\n&quot;</a>);
        }
      } <a id='8397' tid='8398', class="m">else</a> <a id='8399' tid='8400', class="m">if</a> (<a id='8401' tid='8402', class="m">strcmp</a>(<a id='8403' tid='8404', class="m">cmd</a>, <a id='8405' tid='8406', class="m">&quot;stack&quot;</a>) <a id='8407' tid='8408', class="m">==</a> <a id='8409' tid='8410', class="m">0</a> <a id='8411' tid='8412', class="m">||</a> <a id='8413' tid='8414', class="m">strcmp</a>(<a id='8415' tid='8416', class="m">cmd</a>, <a id='8417' tid='8418', class="m">&quot;mem&quot;</a>) <a id='8419' tid='8420', class="m">==</a> <a id='8421' tid='8422', class="m">0</a>) {
        <a id='8423' tid='8424', class="m">int32_t</a><a id='8425' tid='8426', class="m">*</a> <a id='8427' tid='8428', class="m">cur</a> = <a id='8429' tid='8430', class="m">NULL</a>;
        <a id='8431' tid='8432', class="m">int32_t</a><a id='8433' tid='8434', class="m">*</a> <a id='8435' tid='8436', class="m">end</a> = <a id='8437' tid='8438', class="m">NULL</a>;
        <a id='8439' tid='8440', class="m">int</a> <a id='8441' tid='8442', class="m">next_arg</a> = <a id='8443' tid='8444', class="m">1</a>;

        <a id='8445' tid='8446', class="m">if</a> (<a id='8447' tid='8448', class="m">strcmp</a>(<a id='8449' tid='8450', class="m">cmd</a>, <a id='8451' tid='8452', class="m">&quot;stack&quot;</a>) <a id='8453' tid='8454', class="m">==</a> <a id='8455' tid='8456', class="m">0</a>) {
          <a id='8457' tid='8458', class="m">cur</a> <a id='8459' tid='8460', class="m">=</a> <a id='8461' tid='8462', class="m">reinterpret_cast</a>&lt;<a id='8463' tid='8464', class="m">int32_t</a><a id='8465' tid='8466', class="m">*</a>&gt;(<a id='8467' tid='8468', class="m">sim_</a>-&gt;<a id='8469' tid='8470', class="m">get_register</a>(<a id='8471' tid='8472', class="m">Simulator</a><a id='8473' tid='8474', class="m">::</a><a id='8475' tid='8476', class="m">sp</a>));
        } <a id='8477' tid='8478', class="m">else</a> {  // Command &quot;mem&quot;.
          <a id='8479' tid='8480', class="m">int32_t</a> <a id='8481' tid='8482', class="m">value</a>;
          <a id='8483' tid='8484', class="m">if</a> (<a id='8485' tid='8486', class="m">!</a><a id='8487' tid='8488', class="m">GetValue</a>(<a id='8489' tid='8490', class="m">arg1</a>, <a id='8491' tid='8492', class="m">&</a><a id='8493' tid='8494', class="m">value</a>)) {
            <a id='8495' tid='8496', class="m">PrintF</a>(<a id='8497' tid='8498', class="m">&quot;%s unrecognized\n&quot;</a>, <a id='8499' tid='8500', class="m">arg1</a>);
            <a id='8501' tid='8502', class="m">continue</a>;
          }
          <a id='8503' tid='8504', class="m">cur</a> <a id='8505' tid='8506', class="m">=</a> <a id='8507' tid='8508', class="m">reinterpret_cast</a>&lt;<a id='8509' tid='8510', class="m">int32_t</a><a id='8511' tid='8512', class="m">*</a>&gt;(<a id='8513' tid='8514', class="m">value</a>);
          <a id='8515' tid='8516', class="m">next_arg</a><a id='8517' tid='8518', class="m">++</a>;
        }

        <a id='8519' tid='8520', class="m">int32_t</a> <a id='8521' tid='8522', class="m">words</a>;
        <a id='8523' tid='8524', class="m">if</a> (<a id='8525' tid='8526', class="m">argc</a> <a id='8527' tid='8528', class="m">==</a> <a id='8529' tid='8530', class="m">next_arg</a>) {
          <a id='8531' tid='8532', class="m">words</a> <a id='8533' tid='8534', class="m">=</a> <a id='8535' tid='8536', class="m">10</a>;
        } <a id='8537' tid='8538', class="m">else</a> <a id='8539' tid='8540', class="m">if</a> (<a id='8541' tid='8542', class="m">argc</a> <a id='8543' tid='8544', class="m">==</a> <a id='8545' tid='8546', class="m">next_arg</a> <a id='8547' tid='8548', class="m">+</a> <a id='8549' tid='8550', class="m">1</a>) {
          <a id='8551' tid='8552', class="m">if</a> (<a id='8553' tid='8554', class="m">!</a><a id='8555' tid='8556', class="m">GetValue</a>(<a id='8557' tid='8558', class="m">argv</a>[<a id='8559' tid='8560', class="m">next_arg</a>], <a id='8561' tid='8562', class="m">&</a><a id='8563' tid='8564', class="m">words</a>)) {
            <a id='8565' tid='8566', class="m">words</a> <a id='8567' tid='8568', class="m">=</a> <a id='8569' tid='8570', class="m">10</a>;
          }
        }
        <a id='8571' tid='8572', class="m">end</a> <a id='8573' tid='8574', class="m">=</a> <a id='8575' tid='8576', class="m">cur</a> <a id='8577' tid='8578', class="m">+</a> <a id='8579' tid='8580', class="m">words</a>;

        <a id='8581' tid='8582', class="m">while</a> (<a id='8583' tid='8584', class="m">cur</a> <a id='8585' tid='8586', class="m">&lt;</a> <a id='8587' tid='8588', class="m">end</a>) {
          <a id='8589' tid='8590', class="m">PrintF</a>(<a id='8591' tid='8592', class="m">&quot;  0x%08x:  0x%08x %10d&quot;</a>,
                 <a id='8593' tid='8594', class="m">reinterpret_cast</a>&lt;<a id='8595' tid='8596', class="m">intptr_t</a>&gt;(<a id='8597' tid='8598', class="m">cur</a>), <a id='8599' tid='8600', class="m">*</a><a id='8601' tid='8602', class="m">cur</a>, <a id='8603' tid='8604', class="m">*</a><a id='8605' tid='8606', class="m">cur</a>);
          <a id='8607' tid='8608', class="m">HeapObject</a><a id='8609' tid='8610', class="m">*</a> <a id='8611' tid='8612', class="m">obj</a> = <a id='8613' tid='8614', class="m">reinterpret_cast</a>&lt;<a id='8615' tid='8616', class="m">HeapObject</a><a id='8617' tid='8618', class="m">*</a>&gt;(<a id='8619' tid='8620', class="m">*</a><a id='8621' tid='8622', class="m">cur</a>);
          <a id='8623' tid='8624', class="m">int</a> <a id='8625' tid='8626', class="m">value</a> = <a id='8627' tid='8628', class="m">*</a><a id='8629' tid='8630', class="m">cur</a>;
          <a id='8631' tid='8632', class="m">Heap</a><a id='8633' tid='8634', class="m">*</a> <a id='8635' tid='8636', class="m">current_heap</a> = <a id='8637' tid='8638', class="m">v8</a><a id='8639' tid='8640', class="m">::</a><a id='8641' tid='8642', class="m">internal</a><a id='8643' tid='8644', class="m">::</a><a id='8645' tid='8646', class="m">Isolate</a><a id='8647' tid='8648', class="m">::</a><a id='8649' tid='8650', class="m">Current</a>()-&gt;<a id='8651' tid='8652', class="m">heap</a>();
          <a id='8653' tid='8654', class="m">if</a> (<a id='8655' tid='8656', class="m">current_heap</a>-&gt;<a id='8657' tid='8658', class="m">Contains</a>(<a id='8659' tid='8660', class="m">obj</a>) <a id='8661' tid='8662', class="m">||</a> ((<a id='8663' tid='8664', class="m">value</a> <a id='8665' tid='8666', class="m">&</a> <a id='8667' tid='8668', class="m">1</a>) <a id='8669' tid='8670', class="m">==</a> <a id='8671' tid='8672', class="m">0</a>)) {
            <a id='8673' tid='8674', class="m">PrintF</a>(<a id='8675' tid='8676', class="m">&quot; (&quot;</a>);
            <a id='8677' tid='8678', class="m">if</a> ((<a id='8679' tid='8680', class="m">value</a> <a id='8681' tid='8682', class="m">&</a> <a id='8683' tid='8684', class="m">1</a>) <a id='8685' tid='8686', class="m">==</a> <a id='8687' tid='8688', class="m">0</a>) {
              <a id='8689' tid='8690', class="m">PrintF</a>(<a id='8691' tid='8692', class="m">&quot;smi %d&quot;</a>, <a id='8693' tid='8694', class="m">value</a> <a id='8695' tid='8696', class="m">/</a> <a id='8697' tid='8698', class="m">2</a>);
            } <a id='8699' tid='8700', class="m">else</a> {
              <a id='8701' tid='8702', class="m">obj</a>-&gt;<a id='8703' tid='8704', class="m">ShortPrint</a>();
            }
            <a id='8705' tid='8706', class="m">PrintF</a>(<a id='8707' tid='8708', class="m">&quot;)&quot;</a>);
          }
          <a id='8709' tid='8710', class="m">PrintF</a>(<a id='8711' tid='8712', class="m">&quot;\n&quot;</a>);
          <a id='8713' tid='8714', class="m">cur</a><a id='8715' tid='8716', class="m">++</a>;
        }

      } <a id='8717' tid='8718', class="m">else</a> <a id='8719' tid='8720', class="m">if</a> ((<a id='8721' tid='8722', class="m">strcmp</a>(<a id='8723' tid='8724', class="m">cmd</a>, <a id='8725' tid='8726', class="m">&quot;disasm&quot;</a>) <a id='8727' tid='8728', class="m">==</a> <a id='8729' tid='8730', class="m">0</a>) <span class="d">||</span>
                 (<span class="d">strcmp(cmd, &quot;dpc&quot;) == 0</span>) <a id='8731' tid='8732', class="m">||</a>
                 (<a id='8733' tid='8734', class="m">strcmp</a>(<a id='8735' tid='8736', class="m">cmd</a>, <a id='8737' tid='8738', class="m">&quot;di&quot;</a>) <a id='8739' tid='8740', class="m">==</a> <a id='8741' tid='8742', class="m">0</a>)) {
        <span class="d">disasm::NameConverter converter;</span>
        <a id='8743' tid='8744', class="m">disasm</a><a id='8745' tid='8746', class="m">::</a><a id='8747' tid='8748', class="m">Disassembler</a> <a id='8749' tid='8750', class="m">dasm</a>(<a id='8751' tid='8752', class="m">converter</a>);
        // Use a reasonably large buffer.
        <a id='8061' tid='8062', class="m">v8</a><a id='8063' tid='8064', class="m">::</a><a id='8065' tid='8066', class="m">internal</a><a id='8067' tid='8068', class="m">::</a><a id='8069' tid='8070', class="m">EmbeddedVector</a>&lt;<a id='8071' tid='8072', class="m">char</a>, <a id='8073' tid='8074', class="m">256</a>&gt; <a id='8075' tid='8076', class="m">buffer</a>;

        <span class="d">byte* cur = NULL;</span>
        <span class="d">byte* end = NULL;</span>

        <a id='7545' tid='7546', class="m">if</a> (<a id='7547' tid='7548', class="m">argc</a> <a id='7549' tid='7550', class="m">==</a> <a id='7551' tid='7552', class="m">1</a>) {
          <a id='7553' tid='7554', class="m">cur</a> <a id='7555' tid='7556', class="m">=</a> <a id='7557' tid='7558', class="m">reinterpret_cast</a>&lt;<a id='7559' tid='7560', class="m">byte</a><a id='7561' tid='7562', class="m">*</a>&gt;(<a id='7563' tid='7564', class="m">sim_</a>-&gt;<a id='7565' tid='7566', class="m">get_pc</a>());
          <a id='7567' tid='7568', class="m">end</a> <a id='7569' tid='7570', class="m">=</a> <a id='7571' tid='7572', class="m">cur</a> <a id='7573' tid='7574', class="m">+</a> (<a id='7575' tid='7576', class="m">10</a> <a id='7577' tid='7578', class="m">*</a> <a id='7579' tid='7580', class="m">Instruction</a><a id='7581' tid='7582', class="m">::</a><a id='7583' tid='7584', class="m">kInstrSize</a>);
        } <a id='7585' tid='7586', class="m">else</a> <a id='7587' tid='7588', class="m">if</a> (<a id='7589' tid='7590', class="m">argc</a> <a id='7591' tid='7592', class="m">==</a> <a id='7593' tid='7594', class="m">2</a>) {
          <a id='7595' tid='7596', class="m">int</a> <a id='7597' tid='7598', class="m">regnum</a> = <a id='7599' tid='7600', class="m">Registers</a><a id='7601' tid='7602', class="m">::</a><a id='7603' tid='7604', class="m">Number</a>(<a id='7605' tid='7606', class="m">arg1</a>);
          <a id='7607' tid='7608', class="m">if</a> (<span class="d">regnum != kInvalidRegister</span> <span class="d">||</span> <a id='7609' tid='7610', class="m">strncmp</a>(<a id='7611' tid='7612', class="m">arg1</a>, <a id='7613' tid='7614', class="m">&quot;0x&quot;</a>, <a id='7615' tid='7616', class="m">2</a>) <a id='7617' tid='7618', class="m">==</a> <a id='7619' tid='7620', class="m">0</a>) {
            // The argument is an address or a register name.
            <a id='7621' tid='7622', class="m">int32_t</a> <a id='7623' tid='7624', class="m">value</a>;
            <a id='7625' tid='7626', class="m">if</a> (<a id='7627' tid='7628', class="m">GetValue</a>(<a id='7629' tid='7630', class="m">arg1</a>, <a id='7631' tid='7632', class="m">&</a><a id='7633' tid='7634', class="m">value</a>)) {
              <a id='7635' tid='7636', class="m">cur</a> <a id='7637' tid='7638', class="m">=</a> <a id='7639' tid='7640', class="m">reinterpret_cast</a>&lt;<a id='7641' tid='7642', class="m">byte</a><a id='7643' tid='7644', class="m">*</a>&gt;(<a id='7645' tid='7646', class="m">value</a>);
              // Disassemble 10 instructions at &lt;arg1&gt;.
              <a id='7647' tid='7648', class="m">end</a> <a id='7649' tid='7650', class="m">=</a> <a id='7651' tid='7652', class="m">cur</a> <a id='7653' tid='7654', class="m">+</a> (<a id='7655' tid='7656', class="m">10</a> <a id='7657' tid='7658', class="m">*</a> <a id='7659' tid='7660', class="m">Instruction</a><a id='7661' tid='7662', class="m">::</a><a id='7663' tid='7664', class="m">kInstrSize</a>);
            }
          } <a id='7665' tid='7666', class="m">else</a> {
            // The argument is the number of instructions.
            <a id='7667' tid='7668', class="m">int32_t</a> <a id='7669' tid='7670', class="m">value</a>;
            <a id='7671' tid='7672', class="m">if</a> (<a id='7673' tid='7674', class="m">GetValue</a>(<a id='7675' tid='7676', class="m">arg1</a>, <a id='7677' tid='7678', class="m">&</a><a id='7679' tid='7680', class="m">value</a>)) {
              <a id='7681' tid='7682', class="m">cur</a> <a id='7683' tid='7684', class="m">=</a> <a id='7685' tid='7686', class="m">reinterpret_cast</a>&lt;<a id='7687' tid='7688', class="m">byte</a><a id='7689' tid='7690', class="m">*</a>&gt;(<a id='7691' tid='7692', class="m">sim_</a>-&gt;<a id='7693' tid='7694', class="m">get_pc</a>());
              // Disassemble &lt;arg1&gt; instructions.
              <a id='7695' tid='7696', class="m">end</a> <a id='7697' tid='7698', class="m">=</a> <a id='7699' tid='7700', class="m">cur</a> <a id='7701' tid='7702', class="m">+</a> (<a id='7703' tid='7704', class="m">value</a> <a id='7705' tid='7706', class="m">*</a> <a id='7707' tid='7708', class="m">Instruction</a><a id='7709' tid='7710', class="m">::</a><a id='7711' tid='7712', class="m">kInstrSize</a>);
            }
          }
        } <a id='7713' tid='7714', class="m">else</a> {
          <a id='7715' tid='7716', class="m">int32_t</a> <a id='7717' tid='7718', class="m">value1</a>;
          <a id='7719' tid='7720', class="m">int32_t</a> <a id='7721' tid='7722', class="m">value2</a>;
          <a id='7723' tid='7724', class="m">if</a> (<a id='7725' tid='7726', class="m">GetValue</a>(<a id='7727' tid='7728', class="m">arg1</a>, <a id='7729' tid='7730', class="m">&</a><a id='7731' tid='7732', class="m">value1</a>) <a id='7733' tid='7734', class="m">&&</a> <a id='7735' tid='7736', class="m">GetValue</a>(<a id='7737' tid='7738', class="m">arg2</a>, <a id='7739' tid='7740', class="m">&</a><a id='7741' tid='7742', class="m">value2</a>)) {
            <a id='7743' tid='7744', class="m">cur</a> <a id='7745' tid='7746', class="m">=</a> <a id='7747' tid='7748', class="m">reinterpret_cast</a>&lt;<a id='7749' tid='7750', class="m">byte</a><a id='7751' tid='7752', class="m">*</a>&gt;(<a id='7753' tid='7754', class="m">value1</a>);
            <a id='7755' tid='7756', class="m">end</a> <a id='7757' tid='7758', class="m">=</a> <a id='7759' tid='7760', class="m">cur</a> <a id='7761' tid='7762', class="m">+</a> (<a id='7763' tid='7764', class="m">value2</a> <a id='7765' tid='7766', class="m">*</a> <a id='7767' tid='7768', class="m">Instruction</a><a id='7769' tid='7770', class="m">::</a><a id='7771' tid='7772', class="m">kInstrSize</a>);
          }
        }

        <span class="d">while (cur &lt; end) {
          dasm.InstructionDecode(buffer, cur);
          PrintF(&quot;  0x%08x  %s\n&quot;,
              reinterpret_cast&lt;intptr_t&gt;(cur), buffer.start());
          cur += Instruction::kInstrSize;
        }</span>
      } <a id='8753' tid='8754', class="m">else</a> <a id='8755' tid='8756', class="m">if</a> (<a id='8757' tid='8758', class="m">strcmp</a>(<a id='8759' tid='8760', class="m">cmd</a>, <a id='8761' tid='8762', class="m">&quot;gdb&quot;</a>) <a id='8763' tid='8764', class="m">==</a> <a id='8765' tid='8766', class="m">0</a>) {
        <a id='8767' tid='8768', class="m">PrintF</a>(<a id='8769' tid='8770', class="m">&quot;relinquishing control to gdb\n&quot;</a>);
        <a id='8771' tid='8772', class="m">v8</a><a id='8773' tid='8774', class="m">::</a><a id='8775' tid='8776', class="m">internal</a><a id='8777' tid='8778', class="m">::</a><a id='8779' tid='8780', class="m">OS</a><a id='8781' tid='8782', class="m">::</a><a id='8783' tid='8784', class="m">DebugBreak</a>();
        <a id='8785' tid='8786', class="m">PrintF</a>(<a id='8787' tid='8788', class="m">&quot;regaining control from gdb\n&quot;</a>);
      } <a id='8789' tid='8790', class="m">else</a> <a id='8791' tid='8792', class="m">if</a> (<a id='8793' tid='8794', class="m">strcmp</a>(<a id='8795' tid='8796', class="m">cmd</a>, <a id='8797' tid='8798', class="m">&quot;break&quot;</a>) <a id='8799' tid='8800', class="m">==</a> <a id='8801' tid='8802', class="m">0</a>) {
        <a id='8803' tid='8804', class="m">if</a> (<a id='8805' tid='8806', class="m">argc</a> <a id='8807' tid='8808', class="m">==</a> <a id='8809' tid='8810', class="m">2</a>) {
          <a id='8811' tid='8812', class="m">int32_t</a> <a id='8813' tid='8814', class="m">value</a>;
          <a id='8815' tid='8816', class="m">if</a> (<a id='8817' tid='8818', class="m">GetValue</a>(<a id='8819' tid='8820', class="m">arg1</a>, <a id='8821' tid='8822', class="m">&</a><a id='8823' tid='8824', class="m">value</a>)) {
            <a id='8825' tid='8826', class="m">if</a> (<a id='8827' tid='8828', class="m">!</a><a id='8829' tid='8830', class="m">SetBreakpoint</a>(<a id='8831' tid='8832', class="m">reinterpret_cast</a>&lt;<a id='8833' tid='8834', class="m">Instruction</a><a id='8835' tid='8836', class="m">*</a>&gt;(<a id='8837' tid='8838', class="m">value</a>))) {
              <a id='8839' tid='8840', class="m">PrintF</a>(<a id='8841' tid='8842', class="m">&quot;setting breakpoint failed\n&quot;</a>);
            }
          } <a id='8843' tid='8844', class="m">else</a> {
            <a id='8845' tid='8846', class="m">PrintF</a>(<a id='8847' tid='8848', class="m">&quot;%s unrecognized\n&quot;</a>, <a id='8849' tid='8850', class="m">arg1</a>);
          }
        } <a id='8851' tid='8852', class="m">else</a> {
          <a id='8853' tid='8854', class="m">PrintF</a>(<a id='8855' tid='8856', class="m">&quot;break &lt;address&gt;\n&quot;</a>);
        }
      } <a id='8857' tid='8858', class="m">else</a> <a id='8859' tid='8860', class="m">if</a> (<a id='8861' tid='8862', class="m">strcmp</a>(<a id='8863' tid='8864', class="m">cmd</a>, <a id='8865' tid='8866', class="m">&quot;del&quot;</a>) <a id='8867' tid='8868', class="m">==</a> <a id='8869' tid='8870', class="m">0</a>) {
        <a id='8871' tid='8872', class="m">if</a> (<a id='8873' tid='8874', class="m">!</a><a id='8875' tid='8876', class="m">DeleteBreakpoint</a>(<a id='8877' tid='8878', class="m">NULL</a>)) {
          <a id='8879' tid='8880', class="m">PrintF</a>(<a id='8881' tid='8882', class="m">&quot;deleting breakpoint failed\n&quot;</a>);
        }
      } <a id='8883' tid='8884', class="m">else</a> <span class="d">if</span> (<a id='8885' tid='8886', class="m">strcmp</a>(<a id='8887' tid='8888', class="m">cmd</a>, <a id='8889' tid='8890', class="m">&quot;flags&quot;</a>) <a id='8891' tid='8892', class="m">==</a> <a id='8893' tid='8894', class="m">0</a>) <span class="d">{
        PrintF(&quot;No flags on MIPS !\n&quot;);
      }</span> <span class="d">else</span> <a id='7773' tid='7774', class="m">if</a> (<a id='8077' tid='8078', class="m">strcmp</a>(<a id='8079' tid='8080', class="m">cmd</a>, <a id='8081' tid='8082', class="m">&quot;stop&quot;</a>) <a id='8083' tid='8084', class="m">==</a> <a id='8085' tid='8086', class="m">0</a>) {
        <a id='7775' tid='7776', class="m">int32_t</a> <a id='7777' tid='7778', class="m">value</a>;
        <a id='7779' tid='7780', class="m">intptr_t</a> <a id='7781' tid='7782', class="m">stop_pc</a> = <a id='7783' tid='7784', class="m">sim_</a>-&gt;<a id='7785' tid='7786', class="m">get_pc</a>() <a id='7787' tid='7788', class="m">-</a>
            <a id='7789' tid='7790', class="m">2</a> <a id='7791' tid='7792', class="m">*</a> <a id='7793' tid='7794', class="m">Instruction</a><a id='7795' tid='7796', class="m">::</a><a id='7797' tid='7798', class="m">kInstrSize</a>;
        <a id='7799' tid='7800', class="m">Instruction</a><a id='7801' tid='7802', class="m">*</a> <a id='7803' tid='7804', class="m">stop_instr</a> = <a id='7805' tid='7806', class="m">reinterpret_cast</a>&lt;<a id='7807' tid='7808', class="m">Instruction</a><a id='7809' tid='7810', class="m">*</a>&gt;(<a id='7811' tid='7812', class="m">stop_pc</a>);
        <a id='7813' tid='7814', class="m">Instruction</a><a id='7815' tid='7816', class="m">*</a> <a id='7817' tid='7818', class="m">msg_address</a> =
          <a id='7819' tid='7820', class="m">reinterpret_cast</a>&lt;<a id='7821' tid='7822', class="m">Instruction</a><a id='7823' tid='7824', class="m">*</a>&gt;(<a id='7825' tid='7826', class="m">stop_pc</a> <a id='7827' tid='7828', class="m">+</a>
              <a id='7829' tid='7830', class="m">Instruction</a><a id='7831' tid='7832', class="m">::</a><a id='7833' tid='7834', class="m">kInstrSize</a>);
        <a id='7835' tid='7836', class="m">if</a> ((<a id='7837' tid='7838', class="m">argc</a> <a id='7839' tid='7840', class="m">==</a> <a id='7841' tid='7842', class="m">2</a>) <a id='7843' tid='7844', class="m">&&</a> (<a id='7845' tid='7846', class="m">strcmp</a>(<a id='7847' tid='7848', class="m">arg1</a>, <a id='7849' tid='7850', class="m">&quot;unstop&quot;</a>) <a id='7851' tid='7852', class="m">==</a> <a id='7853' tid='7854', class="m">0</a>)) {
          // Remove the current stop.
          <span class="d">if</span> <span class="d">(sim_-&gt;IsStopInstruction(stop_instr))</span> {
            <a id='7855' tid='7856', class="m">stop_instr</a>-&gt;<a id='7857' tid='7858', class="m">SetInstructionBits</a>(<a id='7859' tid='7860', class="m">kNopInstr</a>);
            <a id='7861' tid='7862', class="m">msg_address</a>-&gt;<a id='7863' tid='7864', class="m">SetInstructionBits</a>(<a id='7865' tid='7866', class="m">kNopInstr</a>);
          } <span class="d">else {
            PrintF(&quot;Not at debugger stop.\n&quot;);
          }</span>
        } <a id='7867' tid='7868', class="m">else</a> <a id='7869' tid='7870', class="m">if</a> (<a id='7871' tid='7872', class="m">argc</a> <a id='7873' tid='7874', class="m">==</a> <a id='7875' tid='7876', class="m">3</a>) {
          // Print information about all/the specified breakpoint(s).
          <a id='7877' tid='7878', class="m">if</a> (<a id='7879' tid='7880', class="m">strcmp</a>(<a id='7881' tid='7882', class="m">arg1</a>, <a id='7883' tid='7884', class="m">&quot;info&quot;</a>) <a id='7885' tid='7886', class="m">==</a> <a id='7887' tid='7888', class="m">0</a>) {
            <span class="d">if</span> (<a id='7889' tid='7890', class="m">strcmp</a>(<a id='7891' tid='7892', class="m">arg2</a>, <a id='7893' tid='7894', class="m">&quot;all&quot;</a>) <a id='7895' tid='7896', class="m">==</a> <a id='7897' tid='7898', class="m">0</a>) <span class="d">{
              PrintF(&quot;Stop information:\n&quot;);
              for (uint32_t i = kMaxWatchpointCode + 1;
                   i &lt;= kMaxStopCode;
                   i++) {
                sim_-&gt;PrintStopInfo(i);
              }
            }</span> <a id='7285' tid='7286', class="m">else</a> <a id='7287' tid='7288', class="m">if</a> (<a id='7289' tid='7290', class="m">GetValue</a>(<a id='7291' tid='7292', class="m">arg2</a>, <a id='7293' tid='7294', class="m">&</a><a id='7295' tid='7296', class="m">value</a>)) {
              <a id='7297' tid='7298', class="m">sim_</a>-&gt;<a id='7299' tid='7300', class="m">PrintStopInfo</a>(<a id='7301' tid='7302', class="m">value</a>);
            } <a id='7303' tid='7304', class="m">else</a> {
              <a id='7305' tid='7306', class="m">PrintF</a>(<a id='7307' tid='7308', class="m">&quot;Unrecognized argument.\n&quot;</a>);
            }
          } <a id='7899' tid='7900', class="m">else</a> <a id='7901' tid='7902', class="m">if</a> (<a id='7903' tid='7904', class="m">strcmp</a>(<a id='7905' tid='7906', class="m">arg1</a>, <a id='7907' tid='7908', class="m">&quot;enable&quot;</a>) <a id='7909' tid='7910', class="m">==</a> <a id='7911' tid='7912', class="m">0</a>) {
            // Enable all/the specified breakpoint(s).
            <span class="d">if</span> (<a id='7913' tid='7914', class="m">strcmp</a>(<a id='7915' tid='7916', class="m">arg2</a>, <a id='7917' tid='7918', class="m">&quot;all&quot;</a>) <a id='7919' tid='7920', class="m">==</a> <a id='7921' tid='7922', class="m">0</a>) <span class="d">{
              for (uint32_t i = kMaxWatchpointCode + 1;
                   i &lt;= kMaxStopCode;
                   i++) {
                sim_-&gt;EnableStop(i);
              }
            }</span> <a id='7309' tid='7310', class="m">else</a> <a id='7311' tid='7312', class="m">if</a> (<a id='7313' tid='7314', class="m">GetValue</a>(<a id='7315' tid='7316', class="m">arg2</a>, <a id='7317' tid='7318', class="m">&</a><a id='7319' tid='7320', class="m">value</a>)) {
              <a id='7321' tid='7322', class="m">sim_</a>-&gt;<a id='7323' tid='7324', class="m">EnableStop</a>(<a id='7325' tid='7326', class="m">value</a>);
            } <a id='7327' tid='7328', class="m">else</a> {
              <a id='7329' tid='7330', class="m">PrintF</a>(<a id='7331' tid='7332', class="m">&quot;Unrecognized argument.\n&quot;</a>);
            }
          } <a id='7923' tid='7924', class="m">else</a> <a id='7925' tid='7926', class="m">if</a> (<a id='7927' tid='7928', class="m">strcmp</a>(<a id='7929' tid='7930', class="m">arg1</a>, <a id='7931' tid='7932', class="m">&quot;disable&quot;</a>) <a id='7933' tid='7934', class="m">==</a> <a id='7935' tid='7936', class="m">0</a>) {
            // Disable all/the specified breakpoint(s).
            <span class="d">if</span> (<a id='7937' tid='7938', class="m">strcmp</a>(<a id='7939' tid='7940', class="m">arg2</a>, <a id='7941' tid='7942', class="m">&quot;all&quot;</a>) <a id='7943' tid='7944', class="m">==</a> <a id='7945' tid='7946', class="m">0</a>) <span class="d">{
              for (uint32_t i = kMaxWatchpointCode + 1;
                   i &lt;= kMaxStopCode;
                   i++) {
                sim_-&gt;DisableStop(i);
              }
            }</span> <a id='7333' tid='7334', class="m">else</a> <a id='7335' tid='7336', class="m">if</a> (<a id='7337' tid='7338', class="m">GetValue</a>(<a id='7339' tid='7340', class="m">arg2</a>, <a id='7341' tid='7342', class="m">&</a><a id='7343' tid='7344', class="m">value</a>)) {
              <a id='7345' tid='7346', class="m">sim_</a>-&gt;<a id='7347' tid='7348', class="m">DisableStop</a>(<a id='7349' tid='7350', class="m">value</a>);
            } <a id='7351' tid='7352', class="m">else</a> {
              <a id='7353' tid='7354', class="m">PrintF</a>(<a id='7355' tid='7356', class="m">&quot;Unrecognized argument.\n&quot;</a>);
            }
          }
        } <a id='7947' tid='7948', class="m">else</a> {
          <a id='7949' tid='7950', class="m">PrintF</a>(<a id='7951' tid='7952', class="m">&quot;Wrong usage. Use help command for more information.\n&quot;</a>);
        }
      } <a id='7953' tid='7954', class="m">else</a> <span class="d">if</span> <span class="d">((strcmp(cmd, &quot;stat&quot;) == 0) || (strcmp(cmd, &quot;st&quot;) == 0))</span> {
        // Print registers and disassemble.
        <span class="d">PrintAllRegs();</span>
        <span class="d">PrintF(&quot;\n&quot;);</span>

        <span class="d">disasm::NameConverter converter;</span>
        <a id='4845' tid='4846', class="m">disasm</a><a id='4847' tid='4848', class="m">::</a><a id='4849' tid='4850', class="m">Disassembler</a> <a id='4851' tid='4852', class="m">dasm</a>(<a id='4853' tid='4854', class="m">converter</a>);
        // Use a reasonably large buffer.
        <a id='4711' tid='4712', class="m">v8</a><a id='4713' tid='4714', class="m">::</a><a id='4715' tid='4716', class="m">internal</a><a id='4717' tid='4718', class="m">::</a><a id='4719' tid='4720', class="m">EmbeddedVector</a>&lt;<a id='4721' tid='4722', class="m">char</a>, <a id='4723' tid='4724', class="m">256</a>&gt; <a id='4725' tid='4726', class="m">buffer</a>;

        <span class="d">byte* cur = NULL;</span>
        <span class="d">byte* end = NULL;</span>

        <span class="d">if (argc == 1) {
          cur = reinterpret_cast&lt;byte*&gt;(sim_-&gt;get_pc());
          end = cur + (10 * Instruction::kInstrSize);
        } else if (argc == 2) {
          int32_t value;
          if (GetValue(arg1, &value)) {
            cur = reinterpret_cast&lt;byte*&gt;(value);
            // no length parameter passed, assume 10 instructions
            end = cur + (10 * Instruction::kInstrSize);
          }
        } else {
          int32_t value1;
          int32_t value2;
          if (GetValue(arg1, &value1) && GetValue(arg2, &value2)) {
            cur = reinterpret_cast&lt;byte*&gt;(value1);
            end = cur + (value2 * Instruction::kInstrSize);
          }
        }</span>

        <span class="d">while (cur &lt; end) {
          dasm.InstructionDecode(buffer, cur);
          PrintF(&quot;  0x%08x  %s\n&quot;,
                 reinterpret_cast&lt;intptr_t&gt;(cur), buffer.start());
          cur += Instruction::kInstrSize;
        }</span>
      } <a id='7955' tid='7956', class="m">else</a> <span class="d">if</span> ((<a id='7957' tid='7958', class="m">strcmp</a>(<a id='7959' tid='7960', class="m">cmd</a>, <a id='7961' tid='7962', class="m">&quot;h&quot;</a>) <a id='7963' tid='7964', class="m">==</a> <a id='7965' tid='7966', class="m">0</a>) <a id='7967' tid='7968', class="m">||</a> (<a id='7969' tid='7970', class="m">strcmp</a>(<a id='7971' tid='7972', class="m">cmd</a>, <a id='7973' tid='7974', class="m">&quot;help&quot;</a>) <a id='7975' tid='7976', class="m">==</a> <a id='7977' tid='7978', class="m">0</a>)) <span class="d">{
        PrintF(&quot;cont\n&quot;);
        PrintF(&quot;  continue execution (alias &#39;c&#39;)\n&quot;);
        PrintF(&quot;stepi\n&quot;);
        PrintF(&quot;  step one instruction (alias &#39;si&#39;)\n&quot;);
        PrintF(&quot;print &lt;register&gt;\n&quot;);
        PrintF(&quot;  print register content (alias &#39;p&#39;)\n&quot;);
        PrintF(&quot;  use register name &#39;all&#39; to print all registers\n&quot;);
        PrintF(&quot;printobject &lt;register&gt;\n&quot;);
        PrintF(&quot;  print an object from a register (alias &#39;po&#39;)\n&quot;);
        PrintF(&quot;stack [&lt;words&gt;]\n&quot;);
        PrintF(&quot;  dump stack content, default dump 10 words)\n&quot;);
        PrintF(&quot;mem &lt;address&gt; [&lt;words&gt;]\n&quot;);
        PrintF(&quot;  dump memory content, default dump 10 words)\n&quot;);
        PrintF(&quot;flags\n&quot;);
        PrintF(&quot;  print flags\n&quot;);
        PrintF(&quot;disasm [&lt;instructions&gt;]\n&quot;);
        PrintF(&quot;disasm [&lt;address/register&gt;]\n&quot;);
        PrintF(&quot;disasm [[&lt;address/register&gt;] &lt;instructions&gt;]\n&quot;);
        PrintF(&quot;  disassemble code, default is 10 instructions\n&quot;);
        PrintF(&quot;  from pc (alias &#39;di&#39;)\n&quot;);
        PrintF(&quot;gdb\n&quot;);
        PrintF(&quot;  enter gdb\n&quot;);
        PrintF(&quot;break &lt;address&gt;\n&quot;);
        PrintF(&quot;  set a break point on the address\n&quot;);
        PrintF(&quot;del\n&quot;);
        PrintF(&quot;  delete the breakpoint\n&quot;);
        PrintF(&quot;stop feature:\n&quot;);
        PrintF(&quot;  Description:\n&quot;);
        PrintF(&quot;    Stops are debug instructions inserted by\n&quot;);
        PrintF(&quot;    the Assembler::stop() function.\n&quot;);
        PrintF(&quot;    When hitting a stop, the Simulator will\n&quot;);
        PrintF(&quot;    stop and and give control to the Debugger.\n&quot;);
        PrintF(&quot;    All stop codes are watched:\n&quot;);
        PrintF(&quot;    - They can be enabled / disabled: the Simulator\n&quot;);
        PrintF(&quot;       will / won&#39;t stop when hitting them.\n&quot;);
        PrintF(&quot;    - The Simulator keeps track of how many times they \n&quot;);
        PrintF(&quot;      are met. (See the info command.) Going over a\n&quot;);
        PrintF(&quot;      disabled stop still increases its counter. \n&quot;);
        PrintF(&quot;  Commands:\n&quot;);
        PrintF(&quot;    stop info all/&lt;code&gt; : print infos about number &lt;code&gt;\n&quot;);
        PrintF(&quot;      or all stop(s).\n&quot;);
        PrintF(&quot;    stop enable/disable all/&lt;code&gt; : enables / disables\n&quot;);
        PrintF(&quot;      all or number &lt;code&gt; stop(s)\n&quot;);
        PrintF(&quot;    stop unstop\n&quot;);
        PrintF(&quot;      ignore the stop instruction at the current location\n&quot;);
        PrintF(&quot;      from now on\n&quot;);
      }</span> <span class="d">else {
        PrintF(&quot;Unknown command: %s\n&quot;, cmd);
      }</span>
    }
    <a id='8895' tid='8896', class="m">DeleteArray</a>(<a id='8897' tid='8898', class="m">line</a>);
  }

  // Add all the breakpoints back to stop execution and enter the debugger
  // shell when hit.
  <a id='9159' tid='9160', class="m">RedoBreakpoints</a>();

#<a id='9161' tid='9162', class="m">undef</a> <a id='9163' tid='9164', class="m">COMMAND_SIZE</a>
#<a id='9165' tid='9166', class="m">undef</a> <a id='9167' tid='9168', class="m">ARG_SIZE</a>

#<a id='9169' tid='9170', class="m">undef</a> <a id='9171' tid='9172', class="m">STR</a>
#<a id='9173' tid='9174', class="m">undef</a> <a id='9175' tid='9176', class="m">XSTR</a>
}


<a id='8899' tid='8900', class="m">static</a> <a id='8901' tid='8902', class="m">bool</a> <a id='8903' tid='8904', class="m">ICacheMatch</a>(<a id='8905' tid='8906', class="m">void</a><a id='8907' tid='8908', class="m">*</a> <a id='8909' tid='8910', class="m">one</a>, <a id='8911' tid='8912', class="m">void</a><a id='8913' tid='8914', class="m">*</a> <a id='8915' tid='8916', class="m">two</a>) {
  <a id='8917' tid='8918', class="m">ASSERT</a>((<a id='8919' tid='8920', class="m">reinterpret_cast</a>&lt;<a id='8921' tid='8922', class="m">intptr_t</a>&gt;(<a id='8923' tid='8924', class="m">one</a>) <a id='8925' tid='8926', class="m">&</a> <a id='8927' tid='8928', class="m">CachePage</a><a id='8929' tid='8930', class="m">::</a><a id='8931' tid='8932', class="m">kPageMask</a>) <a id='8933' tid='8934', class="m">==</a> <a id='8935' tid='8936', class="m">0</a>);
  <a id='8937' tid='8938', class="m">ASSERT</a>((<a id='8939' tid='8940', class="m">reinterpret_cast</a>&lt;<a id='8941' tid='8942', class="m">intptr_t</a>&gt;(<a id='8943' tid='8944', class="m">two</a>) <a id='8945' tid='8946', class="m">&</a> <a id='8947' tid='8948', class="m">CachePage</a><a id='8949' tid='8950', class="m">::</a><a id='8951' tid='8952', class="m">kPageMask</a>) <a id='8953' tid='8954', class="m">==</a> <a id='8955' tid='8956', class="m">0</a>);
  <a id='8957' tid='8958', class="m">return</a> <a id='8959' tid='8960', class="m">one</a> <a id='8961' tid='8962', class="m">==</a> <a id='8963' tid='8964', class="m">two</a>;
}


<a id='8087' tid='8088', class="m">static</a> <a id='8089' tid='8090', class="m">uint32_t</a> <a id='8091' tid='8092', class="m">ICacheHash</a>(<a id='8093' tid='8094', class="m">void</a><a id='8095' tid='8096', class="m">*</a> <a id='8097' tid='8098', class="m">key</a>) {
  <a id='8099' tid='8100', class="m">return</a> <a id='8101' tid='8102', class="m">static_cast</a>&lt;<a id='8103' tid='8104', class="m">uint32_t</a>&gt;(<a id='8105' tid='8106', class="m">reinterpret_cast</a>&lt;<a id='8107' tid='8108', class="m">uintptr_t</a>&gt;(<a id='8109' tid='8110', class="m">key</a>)) <a id='8111' tid='8112', class="m">&gt;&gt;</a> <a id='8113' tid='8114', class="m">2</a>;
}


<a id='7979' tid='7980', class="m">static</a> <a id='7981' tid='7982', class="m">bool</a> <a id='7983' tid='7984', class="m">AllOnOnePage</a>(<a id='7985' tid='7986', class="m">uintptr_t</a> <a id='7987' tid='7988', class="m">start</a>, <a id='7989' tid='7990', class="m">int</a> <a id='7991' tid='7992', class="m">size</a>) {
  <a id='7993' tid='7994', class="m">intptr_t</a> <a id='7995' tid='7996', class="m">start_page</a> = (<a id='7997' tid='7998', class="m">start</a> <a id='7999' tid='8000', class="m">&</a> <a id='8001' tid='8002', class="m">~</a><a id='8003' tid='8004', class="m">CachePage</a><a id='8005' tid='8006', class="m">::</a><a id='8007' tid='8008', class="m">kPageMask</a>);
  <a id='8009' tid='8010', class="m">intptr_t</a> <a id='8011' tid='8012', class="m">end_page</a> = ((<a id='8013' tid='8014', class="m">start</a> <a id='8015' tid='8016', class="m">+</a> <a id='8017' tid='8018', class="m">size</a>) <a id='8019' tid='8020', class="m">&</a> <a id='8021' tid='8022', class="m">~</a><a id='8023' tid='8024', class="m">CachePage</a><a id='8025' tid='8026', class="m">::</a><a id='8027' tid='8028', class="m">kPageMask</a>);
  <a id='8029' tid='8030', class="m">return</a> <a id='8031' tid='8032', class="m">start_page</a> <a id='8033' tid='8034', class="m">==</a> <a id='8035' tid='8036', class="m">end_page</a>;
}


<a id='7357' tid='7358', class="m">void</a> <a id='7359' tid='7360', class="m">Simulator</a><a id='7361' tid='7362', class="m">::</a><a id='7363' tid='7364', class="m">FlushICache</a>(<a id='7365' tid='7366', class="m">v8</a><a id='7367' tid='7368', class="m">::</a><a id='7369' tid='7370', class="m">internal</a><a id='7371' tid='7372', class="m">::</a><a id='7373' tid='7374', class="m">HashMap</a><a id='7375' tid='7376', class="m">*</a> <a id='7377' tid='7378', class="m">i_cache</a>,
                            <a id='7379' tid='7380', class="m">void</a><a id='7381' tid='7382', class="m">*</a> <a id='7383' tid='7384', class="m">start_addr</a>,
                            <a id='7385' tid='7386', class="m">size_t</a> <a id='7387' tid='7388', class="m">size</a>) {
  <a id='7389' tid='7390', class="m">intptr_t</a> <a id='7391' tid='7392', class="m">start</a> = <a id='7393' tid='7394', class="m">reinterpret_cast</a>&lt;<a id='7395' tid='7396', class="m">intptr_t</a>&gt;(<a id='7397' tid='7398', class="m">start_addr</a>);
  <a id='7399' tid='7400', class="m">int</a> <a id='7401' tid='7402', class="m">intra_line</a> = (<a id='7403' tid='7404', class="m">start</a> <a id='7405' tid='7406', class="m">&</a> <a id='7407' tid='7408', class="m">CachePage</a><a id='7409' tid='7410', class="m">::</a><a id='7411' tid='7412', class="m">kLineMask</a>);
  <a id='7413' tid='7414', class="m">start</a> <a id='7415' tid='7416', class="m">-=</a> <a id='7417' tid='7418', class="m">intra_line</a>;
  <a id='7419' tid='7420', class="m">size</a> <a id='7421' tid='7422', class="m">+=</a> <a id='7423' tid='7424', class="m">intra_line</a>;
  <a id='7425' tid='7426', class="m">size</a> <a id='7427' tid='7428', class="m">=</a> ((<a id='7429' tid='7430', class="m">size</a> <a id='7431' tid='7432', class="m">-</a> <a id='7433' tid='7434', class="m">1</a>) <a id='7435' tid='7436', class="m">|</a> <a id='7437' tid='7438', class="m">CachePage</a><a id='7439' tid='7440', class="m">::</a><a id='7441' tid='7442', class="m">kLineMask</a>) <a id='7443' tid='7444', class="m">+</a> <a id='7445' tid='7446', class="m">1</a>;
  <a id='7447' tid='7448', class="m">int</a> <a id='7449' tid='7450', class="m">offset</a> = (<a id='7451' tid='7452', class="m">start</a> <a id='7453' tid='7454', class="m">&</a> <a id='7455' tid='7456', class="m">CachePage</a><a id='7457' tid='7458', class="m">::</a><a id='7459' tid='7460', class="m">kPageMask</a>);
  <a id='7461' tid='7462', class="m">while</a> (<a id='7463' tid='7464', class="m">!</a><a id='7465' tid='7466', class="m">AllOnOnePage</a>(<a id='7467' tid='7468', class="m">start</a>, <a id='7469' tid='7470', class="m">size</a> <a id='7471' tid='7472', class="m">-</a> <a id='7473' tid='7474', class="m">1</a>)) {
    <a id='7475' tid='7476', class="m">int</a> <a id='7477' tid='7478', class="m">bytes_to_flush</a> = <a id='7479' tid='7480', class="m">CachePage</a><a id='7481' tid='7482', class="m">::</a><a id='7483' tid='7484', class="m">kPageSize</a> <a id='7485' tid='7486', class="m">-</a> <a id='7487' tid='7488', class="m">offset</a>;
    <a id='7489' tid='7490', class="m">FlushOnePage</a>(<a id='7491' tid='7492', class="m">i_cache</a>, <a id='7493' tid='7494', class="m">start</a>, <a id='7495' tid='7496', class="m">bytes_to_flush</a>);
    <a id='7497' tid='7498', class="m">start</a> <a id='7499' tid='7500', class="m">+=</a> <a id='7501' tid='7502', class="m">bytes_to_flush</a>;
    <a id='7503' tid='7504', class="m">size</a> <a id='7505' tid='7506', class="m">-=</a> <a id='7507' tid='7508', class="m">bytes_to_flush</a>;
    <a id='7509' tid='7510', class="m">ASSERT_EQ</a>(<a id='7511' tid='7512', class="m">0</a>, <a id='7513' tid='7514', class="m">start</a> <a id='7515' tid='7516', class="m">&</a> <a id='7517' tid='7518', class="m">CachePage</a><a id='7519' tid='7520', class="m">::</a><a id='7521' tid='7522', class="m">kPageMask</a>);
    <a id='7523' tid='7524', class="m">offset</a> <a id='7525' tid='7526', class="m">=</a> <a id='7527' tid='7528', class="m">0</a>;
  }
  <a id='7529' tid='7530', class="m">if</a> (<a id='7531' tid='7532', class="m">size</a> <a id='7533' tid='7534', class="m">!=</a> <a id='7535' tid='7536', class="m">0</a>) {
    <a id='7537' tid='7538', class="m">FlushOnePage</a>(<a id='7539' tid='7540', class="m">i_cache</a>, <a id='7541' tid='7542', class="m">start</a>, <a id='7543' tid='7544', class="m">size</a>);
  }
}


<a id='7185' tid='7186', class="m">CachePage</a><a id='7187' tid='7188', class="m">*</a> <a id='7189' tid='7190', class="m">Simulator</a><a id='7191' tid='7192', class="m">::</a><a id='7193' tid='7194', class="m">GetCachePage</a>(<a id='7195' tid='7196', class="m">v8</a><a id='7197' tid='7198', class="m">::</a><a id='7199' tid='7200', class="m">internal</a><a id='7201' tid='7202', class="m">::</a><a id='7203' tid='7204', class="m">HashMap</a><a id='7205' tid='7206', class="m">*</a> <a id='7207' tid='7208', class="m">i_cache</a>, <a id='7209' tid='7210', class="m">void</a><a id='7211' tid='7212', class="m">*</a> <a id='7213' tid='7214', class="m">page</a>) {
  <a id='7215' tid='7216', class="m">v8</a><a id='7217' tid='7218', class="m">::</a><a id='7219' tid='7220', class="m">internal</a><a id='7221' tid='7222', class="m">::</a><a id='7223' tid='7224', class="m">HashMap</a><a id='7225' tid='7226', class="m">::</a><a id='7227' tid='7228', class="m">Entry</a><a id='7229' tid='7230', class="m">*</a> <a id='7231' tid='7232', class="m">entry</a> = <a id='7233' tid='7234', class="m">i_cache</a>-&gt;<a id='7235' tid='7236', class="m">Lookup</a>(<a id='7237' tid='7238', class="m">page</a>,
                                                        <a id='7239' tid='7240', class="m">ICacheHash</a>(<a id='7241' tid='7242', class="m">page</a>),
                                                        <a id='7243' tid='7244', class="m">true</a>);
  <a id='7245' tid='7246', class="m">if</a> (<a id='7247' tid='7248', class="m">entry</a>-&gt;<a id='7249' tid='7250', class="m">value</a> <a id='7251' tid='7252', class="m">==</a> <a id='7253' tid='7254', class="m">NULL</a>) {
    <a id='7255' tid='7256', class="m">CachePage</a><a id='7257' tid='7258', class="m">*</a> <a id='7259' tid='7260', class="m">new_page</a> = <a id='7261' tid='7262', class="m">new</a> <a id='7263' tid='7264', class="m">CachePage</a>();
    <a id='7265' tid='7266', class="m">entry</a>-&gt;<a id='7267' tid='7268', class="m">value</a> <a id='7269' tid='7270', class="m">=</a> <a id='7271' tid='7272', class="m">new_page</a>;
  }
  <a id='7273' tid='7274', class="m">return</a> <a id='7275' tid='7276', class="m">reinterpret_cast</a>&lt;<a id='7277' tid='7278', class="m">CachePage</a><a id='7279' tid='7280', class="m">*</a>&gt;(<a id='7281' tid='7282', class="m">entry</a>-&gt;<a id='7283' tid='7284', class="m">value</a>);
}


// Flush from start up to and not including start + size.
<a id='7017' tid='7018', class="m">void</a> <a id='7019' tid='7020', class="m">Simulator</a><a id='7021' tid='7022', class="m">::</a><a id='7023' tid='7024', class="m">FlushOnePage</a>(<a id='7025' tid='7026', class="m">v8</a><a id='7027' tid='7028', class="m">::</a><a id='7029' tid='7030', class="m">internal</a><a id='7031' tid='7032', class="m">::</a><a id='7033' tid='7034', class="m">HashMap</a><a id='7035' tid='7036', class="m">*</a> <a id='7037' tid='7038', class="m">i_cache</a>,
                             <a id='7039' tid='7040', class="m">intptr_t</a> <a id='7041' tid='7042', class="m">start</a>,
                             <a id='7043' tid='7044', class="m">int</a> <a id='7045' tid='7046', class="m">size</a>) {
  <a id='7047' tid='7048', class="m">ASSERT</a>(<a id='7049' tid='7050', class="m">size</a> <a id='7051' tid='7052', class="m">&lt;=</a> <a id='7053' tid='7054', class="m">CachePage</a><a id='7055' tid='7056', class="m">::</a><a id='7057' tid='7058', class="m">kPageSize</a>);
  <a id='7059' tid='7060', class="m">ASSERT</a>(<a id='7061' tid='7062', class="m">AllOnOnePage</a>(<a id='7063' tid='7064', class="m">start</a>, <a id='7065' tid='7066', class="m">size</a> <a id='7067' tid='7068', class="m">-</a> <a id='7069' tid='7070', class="m">1</a>));
  <a id='7071' tid='7072', class="m">ASSERT</a>((<a id='7073' tid='7074', class="m">start</a> <a id='7075' tid='7076', class="m">&</a> <a id='7077' tid='7078', class="m">CachePage</a><a id='7079' tid='7080', class="m">::</a><a id='7081' tid='7082', class="m">kLineMask</a>) <a id='7083' tid='7084', class="m">==</a> <a id='7085' tid='7086', class="m">0</a>);
  <a id='7087' tid='7088', class="m">ASSERT</a>((<a id='7089' tid='7090', class="m">size</a> <a id='7091' tid='7092', class="m">&</a> <a id='7093' tid='7094', class="m">CachePage</a><a id='7095' tid='7096', class="m">::</a><a id='7097' tid='7098', class="m">kLineMask</a>) <a id='7099' tid='7100', class="m">==</a> <a id='7101' tid='7102', class="m">0</a>);
  <a id='7103' tid='7104', class="m">void</a><a id='7105' tid='7106', class="m">*</a> <a id='7107' tid='7108', class="m">page</a> = <a id='7109' tid='7110', class="m">reinterpret_cast</a>&lt;<a id='7111' tid='7112', class="m">void</a><a id='7113' tid='7114', class="m">*</a>&gt;(<a id='7115' tid='7116', class="m">start</a> <a id='7117' tid='7118', class="m">&</a> (<a id='7119' tid='7120', class="m">~</a><a id='7121' tid='7122', class="m">CachePage</a><a id='7123' tid='7124', class="m">::</a><a id='7125' tid='7126', class="m">kPageMask</a>));
  <a id='7127' tid='7128', class="m">int</a> <a id='7129' tid='7130', class="m">offset</a> = (<a id='7131' tid='7132', class="m">start</a> <a id='7133' tid='7134', class="m">&</a> <a id='7135' tid='7136', class="m">CachePage</a><a id='7137' tid='7138', class="m">::</a><a id='7139' tid='7140', class="m">kPageMask</a>);
  <a id='7141' tid='7142', class="m">CachePage</a><a id='7143' tid='7144', class="m">*</a> <a id='7145' tid='7146', class="m">cache_page</a> = <a id='7147' tid='7148', class="m">GetCachePage</a>(<a id='7149' tid='7150', class="m">i_cache</a>, <a id='7151' tid='7152', class="m">page</a>);
  <a id='7153' tid='7154', class="m">char</a><a id='7155' tid='7156', class="m">*</a> <a id='7157' tid='7158', class="m">valid_bytemap</a> = <a id='7159' tid='7160', class="m">cache_page</a>-&gt;<a id='7161' tid='7162', class="m">ValidityByte</a>(<a id='7163' tid='7164', class="m">offset</a>);
  <a id='7165' tid='7166', class="m">memset</a>(<a id='7167' tid='7168', class="m">valid_bytemap</a>, <a id='7169' tid='7170', class="m">CachePage</a><a id='7171' tid='7172', class="m">::</a><a id='7173' tid='7174', class="m">LINE_INVALID</a>, <a id='7175' tid='7176', class="m">size</a> <a id='7177' tid='7178', class="m">&gt;&gt;</a> <a id='7179' tid='7180', class="m">CachePage</a><a id='7181' tid='7182', class="m">::</a><a id='7183' tid='7184', class="m">kLineShift</a>);
}


<a id='6797' tid='6798', class="m">void</a> <a id='6799' tid='6800', class="m">Simulator</a><a id='6801' tid='6802', class="m">::</a><a id='6803' tid='6804', class="m">CheckICache</a>(<a id='6805' tid='6806', class="m">v8</a><a id='6807' tid='6808', class="m">::</a><a id='6809' tid='6810', class="m">internal</a><a id='6811' tid='6812', class="m">::</a><a id='6813' tid='6814', class="m">HashMap</a><a id='6815' tid='6816', class="m">*</a> <a id='6817' tid='6818', class="m">i_cache</a>,
                            <a id='6819' tid='6820', class="m">Instruction</a><a id='6821' tid='6822', class="m">*</a> <a id='6823' tid='6824', class="m">instr</a>) {
  <a id='6825' tid='6826', class="m">intptr_t</a> <a id='6827' tid='6828', class="m">address</a> = <a id='6829' tid='6830', class="m">reinterpret_cast</a>&lt;<a id='6831' tid='6832', class="m">intptr_t</a>&gt;(<a id='6833' tid='6834', class="m">instr</a>);
  <a id='6835' tid='6836', class="m">void</a><a id='6837' tid='6838', class="m">*</a> <a id='6839' tid='6840', class="m">page</a> = <a id='6841' tid='6842', class="m">reinterpret_cast</a>&lt;<a id='6843' tid='6844', class="m">void</a><a id='6845' tid='6846', class="m">*</a>&gt;(<a id='6847' tid='6848', class="m">address</a> <a id='6849' tid='6850', class="m">&</a> (<a id='6851' tid='6852', class="m">~</a><a id='6853' tid='6854', class="m">CachePage</a><a id='6855' tid='6856', class="m">::</a><a id='6857' tid='6858', class="m">kPageMask</a>));
  <a id='6859' tid='6860', class="m">void</a><a id='6861' tid='6862', class="m">*</a> <a id='6863' tid='6864', class="m">line</a> = <a id='6865' tid='6866', class="m">reinterpret_cast</a>&lt;<a id='6867' tid='6868', class="m">void</a><a id='6869' tid='6870', class="m">*</a>&gt;(<a id='6871' tid='6872', class="m">address</a> <a id='6873' tid='6874', class="m">&</a> (<a id='6875' tid='6876', class="m">~</a><a id='6877' tid='6878', class="m">CachePage</a><a id='6879' tid='6880', class="m">::</a><a id='6881' tid='6882', class="m">kLineMask</a>));
  <a id='6883' tid='6884', class="m">int</a> <a id='6885' tid='6886', class="m">offset</a> = (<a id='6887' tid='6888', class="m">address</a> <a id='6889' tid='6890', class="m">&</a> <a id='6891' tid='6892', class="m">CachePage</a><a id='6893' tid='6894', class="m">::</a><a id='6895' tid='6896', class="m">kPageMask</a>);
  <a id='6897' tid='6898', class="m">CachePage</a><a id='6899' tid='6900', class="m">*</a> <a id='6901' tid='6902', class="m">cache_page</a> = <a id='6903' tid='6904', class="m">GetCachePage</a>(<a id='6905' tid='6906', class="m">i_cache</a>, <a id='6907' tid='6908', class="m">page</a>);
  <a id='6909' tid='6910', class="m">char</a><a id='6911' tid='6912', class="m">*</a> <a id='6913' tid='6914', class="m">cache_valid_byte</a> = <a id='6915' tid='6916', class="m">cache_page</a>-&gt;<a id='6917' tid='6918', class="m">ValidityByte</a>(<a id='6919' tid='6920', class="m">offset</a>);
  <a id='6921' tid='6922', class="m">bool</a> <a id='6923' tid='6924', class="m">cache_hit</a> = (<a id='6925' tid='6926', class="m">*</a><a id='6927' tid='6928', class="m">cache_valid_byte</a> <a id='6929' tid='6930', class="m">==</a> <a id='6931' tid='6932', class="m">CachePage</a><a id='6933' tid='6934', class="m">::</a><a id='6935' tid='6936', class="m">LINE_VALID</a>);
  <a id='6937' tid='6938', class="m">char</a><a id='6939' tid='6940', class="m">*</a> <a id='6941' tid='6942', class="m">cached_line</a> = <a id='6943' tid='6944', class="m">cache_page</a>-&gt;<a id='6945' tid='6946', class="m">CachedData</a>(<a id='6947' tid='6948', class="m">offset</a> <a id='6949' tid='6950', class="m">&</a> <a id='6951' tid='6952', class="m">~</a><a id='6953' tid='6954', class="m">CachePage</a><a id='6955' tid='6956', class="m">::</a><a id='6957' tid='6958', class="m">kLineMask</a>);
  <a id='6959' tid='6960', class="m">if</a> (<a id='6961' tid='6962', class="m">cache_hit</a>) {
    // Check that the data in memory matches the contents of the I-cache.
    <a id='6963' tid='6964', class="m">CHECK</a>(<a id='6965' tid='6966', class="m">memcmp</a>(<a id='6967' tid='6968', class="m">reinterpret_cast</a>&lt;<a id='6969' tid='6970', class="m">void</a><a id='6971' tid='6972', class="m">*</a>&gt;(<a id='6973' tid='6974', class="m">instr</a>),
                 <a id='6975' tid='6976', class="m">cache_page</a>-&gt;<a id='6977' tid='6978', class="m">CachedData</a>(<a id='6979' tid='6980', class="m">offset</a>),
                 <a id='6981' tid='6982', class="m">Instruction</a><a id='6983' tid='6984', class="m">::</a><a id='6985' tid='6986', class="m">kInstrSize</a>) <a id='6987' tid='6988', class="m">==</a> <a id='6989' tid='6990', class="m">0</a>);
  } <a id='6991' tid='6992', class="m">else</a> {
    // Cache miss.  Load memory into the cache.
    <a id='6993' tid='6994', class="m">memcpy</a>(<a id='6995' tid='6996', class="m">cached_line</a>, <a id='6997' tid='6998', class="m">line</a>, <a id='6999' tid='7000', class="m">CachePage</a><a id='7001' tid='7002', class="m">::</a><a id='7003' tid='7004', class="m">kLineLength</a>);
    <a id='7005' tid='7006', class="m">*</a><a id='7007' tid='7008', class="m">cache_valid_byte</a> <a id='7009' tid='7010', class="m">=</a> <a id='7011' tid='7012', class="m">CachePage</a><a id='7013' tid='7014', class="m">::</a><a id='7015' tid='7016', class="m">LINE_VALID</a>;
  }
}


<a id='6747' tid='6748', class="m">void</a> <a id='6749' tid='6750', class="m">Simulator</a><a id='6751' tid='6752', class="m">::</a><a id='6753' tid='6754', class="m">Initialize</a>(<a id='6755' tid='6756', class="m">Isolate</a><a id='6757' tid='6758', class="m">*</a> <a id='6759' tid='6760', class="m">isolate</a>) {
  <a id='6761' tid='6762', class="m">if</a> (<a id='6763' tid='6764', class="m">isolate</a>-&gt;<a id='6765' tid='6766', class="m">simulator_initialized</a>()) <a id='6767' tid='6768', class="m">return</a>;
  <a id='6769' tid='6770', class="m">isolate</a>-&gt;<a id='6771' tid='6772', class="m">set_simulator_initialized</a>(<a id='6773' tid='6774', class="m">true</a>);
  <a id='6775' tid='6776', class="m">::</a><a id='6777' tid='6778', class="m">v8</a><a id='6779' tid='6780', class="m">::</a><a id='6781' tid='6782', class="m">internal</a><a id='6783' tid='6784', class="m">::</a><a id='6785' tid='6786', class="m">ExternalReference</a><a id='6787' tid='6788', class="m">::</a><a id='6789' tid='6790', class="m">set_redirector</a>(<a id='6791' tid='6792', class="m">isolate</a>,
                                                    <a id='6793' tid='6794', class="m">&</a><a id='6795' tid='6796', class="m">RedirectExternalReference</a>);
}


<a id='6697' tid='6698', class="m">Simulator</a><a id='6699' tid='6700', class="m">::</a><a id='6701' tid='6702', class="m">Simulator</a>(<a id='6703' tid='6704', class="m">Isolate</a><a id='6705' tid='6706', class="m">*</a> <a id='6707' tid='6708', class="m">isolate</a>) : <a id='6709' tid='6710', class="m">isolate_</a>(<a id='6711' tid='6712', class="m">isolate</a>) {
  <span class="d">i_cache_ = isolate_-&gt;simulator_i_cache();</span>
  <a id='6713' tid='6714', class="m">if</a> (<a id='6715' tid='6716', class="m">i_cache_</a> <a id='6717' tid='6718', class="m">==</a> <a id='6719' tid='6720', class="m">NULL</a>) {
    <a id='6721' tid='6722', class="m">i_cache_</a> <a id='6723' tid='6724', class="m">=</a> <a id='6725' tid='6726', class="m">new</a> <a id='6727' tid='6728', class="m">v8</a><a id='6729' tid='6730', class="m">::</a><a id='6731' tid='6732', class="m">internal</a><a id='6733' tid='6734', class="m">::</a><a id='6735' tid='6736', class="m">HashMap</a>(<a id='6737' tid='6738', class="m">&</a><a id='6739' tid='6740', class="m">ICacheMatch</a>);
    <a id='6741' tid='6742', class="m">isolate_</a>-&gt;<a id='6743' tid='6744', class="m">set_simulator_i_cache</a>(<a id='6745' tid='6746', class="m">i_cache_</a>);
  }
  <span class="d">Initialize(isolate);</span>
  // Setup simulator support first. Some of this information is needed to
  // setup the architecture state.
  <span class="d">stack_ = reinterpret_cast&lt;char*&gt;(malloc(stack_size_));</span>
  <span class="d">pc_modified_ = false;</span>
  <span class="d">icount_ = 0;</span>
  <span class="d">break_count_ = 0;</span>
  <span class="d">break_pc_ = NULL;</span>
  <span class="d">break_instr_ = 0;</span>

  // Setup architecture state.
  // All registers are initialized to zero to start with.
  <span class="d">for (int i = 0; i &lt; kNumSimuRegisters; i++) {
    registers_[i] = 0;
  }</span>
  <span class="d">for (int i = 0; i &lt; kNumFPURegisters; i++) {
    FPUregisters_[i] = 0;
  }</span>
  <span class="d">FCSR_ = 0;</span>

  // The sp is initialized to point to the bottom (high address) of the
  // allocated stack area. To be safe in potential stack underflows we leave
  // some buffer below.
  <span class="d">registers_[sp] = reinterpret_cast&lt;int32_t&gt;(stack_) + stack_size_ - 64;</span>
  // The ra and pc are initialized to a known bad value that will cause an
  // access violation if the simulator ever tries to execute it.
  <span class="d">registers_[pc] = bad_ra;</span>
  <span class="d">registers_[ra] = bad_ra;</span>
  <span class="d">InitializeCoverage();</span>
  <span class="d">for (int i = 0; i &lt; kNumExceptions; i++) {
    exceptions[i] = 0;
  }</span>
}


// When the generated code calls an external reference we need to catch that in
// the simulator.  The external reference will be a function compiled for the
// host architecture.  We need to call that function instead of trying to
// execute it with the simulator.  We do that by redirecting the external
// reference to a swi (software-interrupt) instruction that is handled by
// the simulator.  We write the original destination of the jump just at a known
// offset from the swi instruction so the simulator knows what to call.
<a id='6473' tid='6474', class="m">class</a> <a id='6475' tid='6476', class="m">Redirection</a> {
 <a id='6669' tid='6670', class="m">public</a>:
  <a id='6331' tid='6332', class="m">Redirection</a>(<a id='6615' tid='6616', class="m">void</a><a id='6617' tid='6618', class="m">*</a> <a id='6619' tid='6620', class="m">external_function</a>, <a id='6621' tid='6622', class="m">ExternalReference</a><a id='6623' tid='6624', class="m">::</a><a id='6625' tid='6626', class="m">Type</a> <a id='6627' tid='6628', class="m">type</a>)
      : <span class="d">external_function_(external_function),
        swi_instruction_(rtCallRedirInstr),
        type_(type),
        next_(NULL)</span> {
    <a id='6371' tid='6372', class="m">Isolate</a><a id='6373' tid='6374', class="m">*</a> <a id='6375' tid='6376', class="m">isolate</a> = <a id='6377' tid='6378', class="m">Isolate</a><a id='6379' tid='6380', class="m">::</a><a id='6381' tid='6382', class="m">Current</a>();
    <a id='6383' tid='6384', class="m">next_</a> <a id='6385' tid='6386', class="m">=</a> <a id='6387' tid='6388', class="m">isolate</a>-&gt;<a id='6389' tid='6390', class="m">simulator_redirection</a>();
    <a id='6391' tid='6392', class="m">Simulator</a><a id='6393' tid='6394', class="m">::</a><a id='6395' tid='6396', class="m">current</a>(<a id='6397' tid='6398', class="m">isolate</a>)-&gt;
        <a id='6399' tid='6400', class="m">FlushICache</a>(<a id='6401' tid='6402', class="m">isolate</a>-&gt;<a id='6403' tid='6404', class="m">simulator_i_cache</a>(),
                    <a id='6405' tid='6406', class="m">reinterpret_cast</a>&lt;<a id='6407' tid='6408', class="m">void</a><a id='6409' tid='6410', class="m">*</a>&gt;(<a id='6411' tid='6412', class="m">&</a><a id='6413' tid='6414', class="m">swi_instruction_</a>),
                    <a id='6415' tid='6416', class="m">Instruction</a><a id='6417' tid='6418', class="m">::</a><a id='6419' tid='6420', class="m">kInstrSize</a>);
    <a id='6421' tid='6422', class="m">isolate</a>-&gt;<a id='6423' tid='6424', class="m">set_simulator_redirection</a>(<a id='6425' tid='6426', class="m">this</a>);
  }

  <a id='6629' tid='6630', class="m">void</a><a id='6631' tid='6632', class="m">*</a> <a id='6633' tid='6634', class="m">address_of_swi_instruction</a>() {
    <a id='6635' tid='6636', class="m">return</a> <a id='6637' tid='6638', class="m">reinterpret_cast</a>&lt;<a id='6639' tid='6640', class="m">void</a><a id='6641' tid='6642', class="m">*</a>&gt;(<a id='6643' tid='6644', class="m">&</a><a id='6645' tid='6646', class="m">swi_instruction_</a>);
  }

  <a id='6647' tid='6648', class="m">void</a><a id='6649' tid='6650', class="m">*</a> <a id='6651' tid='6652', class="m">external_function</a>() { <a id='6653' tid='6654', class="m">return</a> <a id='6655' tid='6656', class="m">external_function_</a>; }
  <a id='6657' tid='6658', class="m">ExternalReference</a><a id='6659' tid='6660', class="m">::</a><a id='6661' tid='6662', class="m">Type</a> <a id='6663' tid='6664', class="m">type</a>() { <a id='6665' tid='6666', class="m">return</a> <a id='6667' tid='6668', class="m">type_</a>; }

  <a id='6531' tid='6532', class="m">static</a> <a id='6533' tid='6534', class="m">Redirection</a><a id='6535' tid='6536', class="m">*</a> <a id='6537' tid='6538', class="m">Get</a>(<a id='6539' tid='6540', class="m">void</a><a id='6541' tid='6542', class="m">*</a> <a id='6543' tid='6544', class="m">external_function</a>,
                          <a id='6545' tid='6546', class="m">ExternalReference</a><a id='6547' tid='6548', class="m">::</a><a id='6549' tid='6550', class="m">Type</a> <a id='6551' tid='6552', class="m">type</a>) {
    <a id='6553' tid='6554', class="m">Isolate</a><a id='6555' tid='6556', class="m">*</a> <a id='6557' tid='6558', class="m">isolate</a> = <a id='6559' tid='6560', class="m">Isolate</a><a id='6561' tid='6562', class="m">::</a><a id='6563' tid='6564', class="m">Current</a>();
    <a id='6565' tid='6566', class="m">Redirection</a><a id='6567' tid='6568', class="m">*</a> <a id='6569' tid='6570', class="m">current</a> = <a id='6571' tid='6572', class="m">isolate</a>-&gt;<a id='6573' tid='6574', class="m">simulator_redirection</a>();
    <a id='6575' tid='6576', class="m">for</a> (; <a id='6577' tid='6578', class="m">current</a> <a id='6579' tid='6580', class="m">!=</a> <a id='6581' tid='6582', class="m">NULL</a>; <a id='6583' tid='6584', class="m">current</a> <a id='6585' tid='6586', class="m">=</a> <a id='6587' tid='6588', class="m">current</a>-&gt;<a id='6589' tid='6590', class="m">next_</a>) {
      <a id='6591' tid='6592', class="m">if</a> (<a id='6593' tid='6594', class="m">current</a>-&gt;<a id='6595' tid='6596', class="m">external_function_</a> <a id='6597' tid='6598', class="m">==</a> <a id='6599' tid='6600', class="m">external_function</a>) <a id='6601' tid='6602', class="m">return</a> <a id='6603' tid='6604', class="m">current</a>;
    }
    <a id='6605' tid='6606', class="m">return</a> <a id='6607' tid='6608', class="m">new</a> <a id='6609' tid='6610', class="m">Redirection</a>(<a id='6611' tid='6612', class="m">external_function</a>, <a id='6613' tid='6614', class="m">type</a>);
  }

  <a id='6477' tid='6478', class="m">static</a> <a id='6479' tid='6480', class="m">Redirection</a><a id='6481' tid='6482', class="m">*</a> <a id='6483' tid='6484', class="m">FromSwiInstruction</a>(<a id='6485' tid='6486', class="m">Instruction</a><a id='6487' tid='6488', class="m">*</a> <a id='6489' tid='6490', class="m">swi_instruction</a>) {
    <a id='6491' tid='6492', class="m">char</a><a id='6493' tid='6494', class="m">*</a> <a id='6495' tid='6496', class="m">addr_of_swi</a> = <a id='6497' tid='6498', class="m">reinterpret_cast</a>&lt;<a id='6499' tid='6500', class="m">char</a><a id='6501' tid='6502', class="m">*</a>&gt;(<a id='6503' tid='6504', class="m">swi_instruction</a>);
    <a id='6505' tid='6506', class="m">char</a><a id='6507' tid='6508', class="m">*</a> <a id='6509' tid='6510', class="m">addr_of_redirection</a> =
        <a id='6511' tid='6512', class="m">addr_of_swi</a> <a id='6513' tid='6514', class="m">-</a> <a id='6515' tid='6516', class="m">OFFSET_OF</a>(<a id='6517' tid='6518', class="m">Redirection</a>, <a id='6519' tid='6520', class="m">swi_instruction_</a>);
    <a id='6521' tid='6522', class="m">return</a> <a id='6523' tid='6524', class="m">reinterpret_cast</a>&lt;<a id='6525' tid='6526', class="m">Redirection</a><a id='6527' tid='6528', class="m">*</a>&gt;(<a id='6529' tid='6530', class="m">addr_of_redirection</a>);
  }

 <a id='6671' tid='6672', class="m">private</a>:
  <a id='6673' tid='6674', class="m">void</a><a id='6675' tid='6676', class="m">*</a> <a id='6677' tid='6678', class="m">external_function_</a>;
  <a id='6679' tid='6680', class="m">uint32_t</a> <a id='6681' tid='6682', class="m">swi_instruction_</a>;
  <a id='6683' tid='6684', class="m">ExternalReference</a><a id='6685' tid='6686', class="m">::</a><a id='6687' tid='6688', class="m">Type</a> <a id='6689' tid='6690', class="m">type_</a>;
  <a id='6691' tid='6692', class="m">Redirection</a><a id='6693' tid='6694', class="m">*</a> <a id='6695' tid='6696', class="m">next_</a>;
};


<a id='6427' tid='6428', class="m">void</a><a id='6429' tid='6430', class="m">*</a> <a id='6431' tid='6432', class="m">Simulator</a><a id='6433' tid='6434', class="m">::</a><a id='6435' tid='6436', class="m">RedirectExternalReference</a>(<a id='6437' tid='6438', class="m">void</a><a id='6439' tid='6440', class="m">*</a> <a id='6441' tid='6442', class="m">external_function</a>,
                                           <a id='6443' tid='6444', class="m">ExternalReference</a><a id='6445' tid='6446', class="m">::</a><a id='6447' tid='6448', class="m">Type</a> <a id='6449' tid='6450', class="m">type</a>) {
  <a id='6451' tid='6452', class="m">Redirection</a><a id='6453' tid='6454', class="m">*</a> <a id='6455' tid='6456', class="m">redirection</a> = <a id='6457' tid='6458', class="m">Redirection</a><a id='6459' tid='6460', class="m">::</a><a id='6461' tid='6462', class="m">Get</a>(<a id='6463' tid='6464', class="m">external_function</a>, <a id='6465' tid='6466', class="m">type</a>);
  <a id='6467' tid='6468', class="m">return</a> <a id='6469' tid='6470', class="m">redirection</a>-&gt;<a id='6471' tid='6472', class="m">address_of_swi_instruction</a>();
}


// Get the active Simulator for the current thread.
<a id='6333' tid='6334', class="m">Simulator</a><a id='6335' tid='6336', class="m">*</a> <a id='6337' tid='6338', class="m">Simulator</a><a id='6339' tid='6340', class="m">::</a><a id='6341' tid='6342', class="m">current</a>(<a id='6343' tid='6344', class="m">Isolate</a><a id='6345' tid='6346', class="m">*</a> <a id='6347' tid='6348', class="m">isolate</a>) {
  <a id='6349' tid='6350', class="m">v8</a><a id='6351' tid='6352', class="m">::</a><a id='6353' tid='6354', class="m">internal</a><a id='6355' tid='6356', class="m">::</a><a id='6357' tid='6358', class="m">Isolate</a><a id='6359' tid='6360', class="m">::</a><a id='6361' tid='6362', class="m">PerIsolateThreadData</a><a id='6363' tid='6364', class="m">*</a> <a id='6365' tid='6366', class="m">isolate_data</a> =
       <a id='6367' tid='6368', class="m">isolate</a>-&gt;<a id='6369' tid='6370', class="m">FindOrAllocatePerThreadDataForThisThread</a>();
  <span class="d">ASSERT(isolate_data != NULL);</span>
  <span class="d">ASSERT(isolate_data != NULL);</span>

  <a id='6321' tid='6322', class="m">Simulator</a><a id='6323' tid='6324', class="m">*</a> <a id='6325' tid='6326', class="m">sim</a> = <a id='6327' tid='6328', class="m">isolate_data</a>-&gt;<a id='6329' tid='6330', class="m">simulator</a>();
  <a id='6267' tid='6268', class="m">if</a> (<a id='6269' tid='6270', class="m">sim</a> <a id='6271' tid='6272', class="m">==</a> <a id='6273' tid='6274', class="m">NULL</a>) {
    // TODO(146): delete the simulator object when a thread/isolate goes away.
    <a id='6275' tid='6276', class="m">sim</a> <a id='6277' tid='6278', class="m">=</a> <a id='6279' tid='6280', class="m">new</a> <a id='6281' tid='6282', class="m">Simulator</a>(<a id='6283' tid='6284', class="m">isolate</a>);
    <a id='6285' tid='6286', class="m">isolate_data</a>-&gt;<a id='6287' tid='6288', class="m">set_simulator</a>(<a id='6289' tid='6290', class="m">sim</a>);
  }
  <span class="d">return sim;</span>
}


// Sets the register in the architecture state. It will also deal with updating
// Simulator internal state for special registers such as PC.
<a id='6291' tid='6292', class="m">void</a> <a id='6293' tid='6294', class="m">Simulator</a><a id='6295' tid='6296', class="m">::</a><a id='6297' tid='6298', class="m">set_register</a>(<a id='6299' tid='6300', class="m">int</a> <a id='6301' tid='6302', class="m">reg</a>, <a id='6303' tid='6304', class="m">int32_t</a> <a id='6305' tid='6306', class="m">value</a>) {
  <span class="d">ASSERT((reg &gt;= 0) && (reg &lt; kNumSimuRegisters));</span>
  <a id='6307' tid='6308', class="m">if</a> (<a id='6309' tid='6310', class="m">reg</a> <a id='6311' tid='6312', class="m">==</a> <a id='6313' tid='6314', class="m">pc</a>) {
    <a id='6315' tid='6316', class="m">pc_modified_</a> <a id='6317' tid='6318', class="m">=</a> <a id='6319' tid='6320', class="m">true</a>;
  }

  // Zero register always holds 0.
  <span class="d">registers_[reg] = (reg == 0) ? 0 : value;</span>
}


<span class="d">void Simulator::set_fpu_register(int fpureg, int32_t value) {
  ASSERT((fpureg &gt;= 0) && (fpureg &lt; kNumFPURegisters));
  FPUregisters_[fpureg] = value;
}</span>


<span class="d">void Simulator::set_fpu_register_float(int fpureg, float value) {
  ASSERT((fpureg &gt;= 0) && (fpureg &lt; kNumFPURegisters));
  *BitCast&lt;float*&gt;(&FPUregisters_[fpureg]) = value;
}</span>


<span class="d">void Simulator::set_fpu_register_double(int fpureg, double value) {
  ASSERT((fpureg &gt;= 0) && (fpureg &lt; kNumFPURegisters) && ((fpureg % 2) == 0));
  *BitCast&lt;double*&gt;(&FPUregisters_[fpureg]) = value;
}</span>


// Get the register from the architecture state. This function does handle
// the special case of accessing the PC register.
<a id='6253' tid='6254', class="m">int32_t</a> <a id='6255' tid='6256', class="m">Simulator</a><a id='6257' tid='6258', class="m">::</a><a id='6259' tid='6260', class="m">get_register</a>(<a id='6261' tid='6262', class="m">int</a> <a id='6263' tid='6264', class="m">reg</a>) <a id='6265' tid='6266', class="m">const</a> {
  <span class="d">ASSERT((reg &gt;= 0) && (reg &lt; kNumSimuRegisters));</span>
  <span class="d">if</span> <span class="d">(reg == 0)</span>
    <span class="d">return 0;</span>
  <span class="d">else</span>
    <a id='6231' tid='6232', class="m">return</a> <a id='6233' tid='6234', class="m">registers_</a>[<a id='6235' tid='6236', class="m">reg</a>] <a id='6237' tid='6238', class="m">+</a> ((<a id='6239' tid='6240', class="m">reg</a> <a id='6241' tid='6242', class="m">==</a> <a id='6243' tid='6244', class="m">pc</a>) ? <a id='6245' tid='6246', class="m">Instruction</a><a id='6247' tid='6248', class="m">::</a><a id='6249' tid='6250', class="m">kPCReadOffset</a> : <a id='6251' tid='6252', class="m">0</a>);
}


<span class="d">int32_t Simulator::get_fpu_register(int fpureg) const</span> <span class="d">{
  ASSERT((fpureg &gt;= 0) && (fpureg &lt; kNumFPURegisters));
  return FPUregisters_[fpureg];
}</span>


<span class="d">int64_t Simulator::get_fpu_register_long(int fpureg) const</span> <span class="d">{
  ASSERT((fpureg &gt;= 0) && (fpureg &lt; kNumFPURegisters) && ((fpureg % 2) == 0));
  return *BitCast&lt;int64_t*&gt;(
      const_cast&lt;int32_t*&gt;(&FPUregisters_[fpureg]));
}</span>


<span class="d">float Simulator::get_fpu_register_float(int fpureg) const</span> <span class="d">{
  ASSERT((fpureg &gt;= 0) && (fpureg &lt; kNumFPURegisters));
  return *BitCast&lt;float*&gt;(
      const_cast&lt;int32_t*&gt;(&FPUregisters_[fpureg]));
}</span>


<span class="d">double Simulator::get_fpu_register_double(int fpureg) const</span> <span class="d">{
  ASSERT((fpureg &gt;= 0) && (fpureg &lt; kNumFPURegisters) && ((fpureg % 2) == 0));
  return *BitCast&lt;double*&gt;(const_cast&lt;int32_t*&gt;(&FPUregisters_[fpureg]));
}</span>


// For use in calls that take two double values, constructed either
// from a0-a3 or f12 and f14.
<a id='6153' tid='6154', class="m">void</a> <a id='6155' tid='6156', class="m">Simulator</a><a id='6157' tid='6158', class="m">::</a><a id='6159' tid='6160', class="m">GetFpArgs</a>(<a id='6161' tid='6162', class="m">double</a><a id='6163' tid='6164', class="m">*</a> <a id='6165' tid='6166', class="m">x</a>, <a id='6167' tid='6168', class="m">double</a><a id='6169' tid='6170', class="m">*</a> <a id='6171' tid='6172', class="m">y</a>) {
  <span class="d">if</span> <span class="d">(!IsMipsSoftFloatABI)</span> <span class="d">{
    *x = get_fpu_register_double(12);
    *y = get_fpu_register_double(14);
  }</span> <a id='6173' tid='6174', class="m">else</a> {
    // We use a char buffer to get around the strict-aliasing rules which
    // otherwise allow the compiler to optimize away the copy.
    <a id='6175' tid='6176', class="m">char</a> <a id='6177' tid='6178', class="m">buffer</a>[<a id='6179' tid='6180', class="m">sizeof</a>(<a id='6181' tid='6182', class="m">*</a><a id='6183' tid='6184', class="m">x</a>)];
    <span class="d">int32_t* reg_buffer = reinterpret_cast&lt;int32_t*&gt;(buffer);</span>

    // Registers a0 and a1 -&gt; x.
    <span class="d">reg_buffer[0] = get_register(a0);</span>
    <span class="d">reg_buffer[1] = get_register(a1);</span>
    <span class="d">memcpy(x, buffer, sizeof(buffer));</span>

    // Registers a2 and a3 -&gt; y.
    <span class="d">reg_buffer[0] = get_register(a2);</span>
    <span class="d">reg_buffer[1] = get_register(a3);</span>
    <span class="d">memcpy(y, buffer, sizeof(buffer));</span>
  }
}


// For use in calls that take one double value, constructed either
// from a0 and a1 or f12.
<a id='6129' tid='6130', class="m">void</a> <a id='6131' tid='6132', class="m">Simulator</a><a id='6133' tid='6134', class="m">::</a><a id='6135' tid='6136', class="m">GetFpArgs</a>(<a id='6137' tid='6138', class="m">double</a><a id='6139' tid='6140', class="m">*</a> <a id='6141' tid='6142', class="m">x</a>) {
  <span class="d">if</span> <span class="d">(!IsMipsSoftFloatABI)</span> <span class="d">{
    *x = get_fpu_register_double(12);
  }</span> <span class="d">else</span> {
    // We use a char buffer to get around the strict-aliasing rules which
    // otherwise allow the compiler to optimize away the copy.
    <a id='6143' tid='6144', class="m">char</a> <a id='6145' tid='6146', class="m">buffer</a>[<a id='6147' tid='6148', class="m">sizeof</a>(<a id='6149' tid='6150', class="m">*</a><a id='6151' tid='6152', class="m">x</a>)];
    <span class="d">int32_t* reg_buffer = reinterpret_cast&lt;int32_t*&gt;(buffer);</span>
    // Registers a0 and a1 -&gt; x.
    <span class="d">reg_buffer[0] = get_register(a0);</span>
    <span class="d">reg_buffer[1] = get_register(a1);</span>
    <span class="d">memcpy(x, buffer, sizeof(buffer));</span>
  }
}


// For use in calls that take one double value constructed either
// from a0 and a1 or f12 and one integer value.
<a id='6097' tid='6098', class="m">void</a> <a id='6099' tid='6100', class="m">Simulator</a><a id='6101' tid='6102', class="m">::</a><a id='6103' tid='6104', class="m">GetFpArgs</a>(<a id='6105' tid='6106', class="m">double</a><a id='6107' tid='6108', class="m">*</a> <a id='6109' tid='6110', class="m">x</a>, <a id='6111' tid='6112', class="m">int32_t</a><a id='6113' tid='6114', class="m">*</a> <a id='6115' tid='6116', class="m">y</a>) {
  <span class="d">if</span> <span class="d">(!IsMipsSoftFloatABI)</span> <span class="d">{
    *x = get_fpu_register_double(12);
    *y = get_register(a2);
  }</span> <a id='6117' tid='6118', class="m">else</a> {
    // We use a char buffer to get around the strict-aliasing rules which
    // otherwise allow the compiler to optimize away the copy.
    <a id='6119' tid='6120', class="m">char</a> <a id='6121' tid='6122', class="m">buffer</a>[<a id='6123' tid='6124', class="m">sizeof</a>(<a id='6125' tid='6126', class="m">*</a><a id='6127' tid='6128', class="m">x</a>)];
    <span class="d">int32_t* reg_buffer = reinterpret_cast&lt;int32_t*&gt;(buffer);</span>
    // Registers 0 and 1 -&gt; x.
    <span class="d">reg_buffer[0] = get_register(a0);</span>
    <span class="d">reg_buffer[1] = get_register(a1);</span>
    <span class="d">memcpy(x, buffer, sizeof(buffer));</span>

    // Register 2 -&gt; y.
    <span class="d">reg_buffer[0] = get_register(a2);</span>
    <a id='6085' tid='6086', class="m">memcpy</a>(<a id='6087' tid='6088', class="m">y</a>, <a id='6089' tid='6090', class="m">buffer</a>, <a id='6091' tid='6092', class="m">sizeof</a>(<a id='6093' tid='6094', class="m">*</a><a id='6095' tid='6096', class="m">y</a>));
  }
}


// The return value is either in v0/v1 or f0.
<a id='6057' tid='6058', class="m">void</a> <a id='6059' tid='6060', class="m">Simulator</a><a id='6061' tid='6062', class="m">::</a><a id='6063' tid='6064', class="m">SetFpResult</a>(<a id='6065' tid='6066', class="m">const</a> <a id='6067' tid='6068', class="m">double</a><a id='6069' tid='6070', class="m">&</a> <a id='6071' tid='6072', class="m">result</a>) {
  <span class="d">if</span> <span class="d">(!IsMipsSoftFloatABI)</span> <span class="d">{
    set_fpu_register_double(0, result);
  }</span> <span class="d">else</span> {
    <a id='6043' tid='6044', class="m">char</a> <a id='6045' tid='6046', class="m">buffer</a>[<a id='6047' tid='6048', class="m">2</a> <a id='6049' tid='6050', class="m">*</a> <a id='6051' tid='6052', class="m">sizeof</a>(<a id='6053' tid='6054', class="m">registers_</a>[<a id='6055' tid='6056', class="m">0</a>])];
    <span class="d">int32_t* reg_buffer = reinterpret_cast&lt;int32_t*&gt;(buffer);</span>
    <a id='6073' tid='6074', class="m">memcpy</a>(<a id='6075' tid='6076', class="m">buffer</a>, <a id='6077' tid='6078', class="m">&</a><a id='6079' tid='6080', class="m">result</a>, <a id='6081' tid='6082', class="m">sizeof</a>(<a id='6083' tid='6084', class="m">buffer</a>));
    // Copy result to v0 and v1.
    <span class="d">set_register(v0, reg_buffer[0]);</span>
    <span class="d">set_register(v1, reg_buffer[1]);</span>
  }
}


// Helper functions for setting and testing the FCSR register&#39;s bits.
<span class="d">void Simulator::set_fcsr_bit(uint32_t cc, bool value) {
  if (value) {
    FCSR_ |= (1 &lt;&lt; cc);
  } else {
    FCSR_ &= ~(1 &lt;&lt; cc);
  }
}</span>


<span class="d">bool Simulator::test_fcsr_bit(uint32_t cc) {
  return FCSR_ & (1 &lt;&lt; cc);
}</span>


// Sets the rounding error codes in FCSR based on the result of the rounding.
// Returns true if the operation was invalid.
<span class="d">bool Simulator::set_fcsr_round_error(double original, double rounded) {
  bool ret = false;

  if (!isfinite(original) || !isfinite(rounded)) {
    set_fcsr_bit(kFCSRInvalidOpFlagBit, true);
    ret = true;
  }

  if (original != rounded) {
    set_fcsr_bit(kFCSRInexactFlagBit, true);
  }

  if (rounded &lt; DBL_MIN && rounded &gt; -DBL_MIN && rounded != 0) {
    set_fcsr_bit(kFCSRUnderflowFlagBit, true);
    ret = true;
  }

  if (rounded &gt; INT_MAX || rounded &lt; INT_MIN) {
    set_fcsr_bit(kFCSROverflowFlagBit, true);
    // The reference is not really clear but it seems this is required:
    set_fcsr_bit(kFCSRInvalidOpFlagBit, true);
    ret = true;
  }

  return ret;
}</span>


// Raw access to the PC register.
<a id='6205' tid='6206', class="m">void</a> <a id='6207' tid='6208', class="m">Simulator</a><a id='6209' tid='6210', class="m">::</a><a id='6211' tid='6212', class="m">set_pc</a>(<a id='6213' tid='6214', class="m">int32_t</a> <a id='6215' tid='6216', class="m">value</a>) {
  <a id='6217' tid='6218', class="m">pc_modified_</a> <a id='6219' tid='6220', class="m">=</a> <a id='6221' tid='6222', class="m">true</a>;
  <a id='6223' tid='6224', class="m">registers_</a>[<a id='6225' tid='6226', class="m">pc</a>] <a id='6227' tid='6228', class="m">=</a> <a id='6229' tid='6230', class="m">value</a>;
}


<a id='6195' tid='6196', class="m">bool</a> <a id='6197' tid='6198', class="m">Simulator</a><a id='6199' tid='6200', class="m">::</a><a id='6201' tid='6202', class="m">has_bad_pc</a>() <a id='6203' tid='6204', class="m">const</a> <span class="d">{
  return ((registers_[pc] == bad_ra) || (registers_[pc] == end_sim_pc));
}</span>


// Raw access to the PC register without the special adjustment when reading.
<a id='6185' tid='6186', class="m">int32_t</a> <a id='6187' tid='6188', class="m">Simulator</a><a id='6189' tid='6190', class="m">::</a><a id='6191' tid='6192', class="m">get_pc</a>() <a id='6193' tid='6194', class="m">const</a> <span class="d">{
  return registers_[pc];
}</span>


// The MIPS cannot do unaligned reads and writes.  On some MIPS platforms an
// interrupt is caused.  On others it does a funky rotation thing.  For now we
// simply disallow unaligned reads, but at some point we may want to move to
// emulating the rotate behaviour.  Note that simulator runs have the runtime
// system running directly on the host system and only generated code is
// executed in the simulator.  Since the host is typically IA32 we will not
// get the correct MIPS-like behaviour on unaligned accesses.

<a id='6011' tid='6012', class="m">int</a> <a id='6013' tid='6014', class="m">Simulator</a><a id='6015' tid='6016', class="m">::</a><a id='6017' tid='6018', class="m">ReadW</a>(<a id='6019' tid='6020', class="m">int32_t</a> <a id='6021' tid='6022', class="m">addr</a>, <a id='6023' tid='6024', class="m">Instruction</a><a id='6025' tid='6026', class="m">*</a> <a id='6027' tid='6028', class="m">instr</a>) {
  <span class="d">if (addr &gt;=0 && addr &lt; 0x400) {
    // This has to be a NULL-dereference, drop into debugger.
    MipsDebugger dbg(this);
    dbg.Debug();
  }</span>
  <span class="d">if</span> <span class="d">((addr & kPointerAlignmentMask) == 0)</span> {
    <a id='6029' tid='6030', class="m">intptr_t</a><a id='6031' tid='6032', class="m">*</a> <a id='6033' tid='6034', class="m">ptr</a> = <a id='6035' tid='6036', class="m">reinterpret_cast</a>&lt;<a id='6037' tid='6038', class="m">intptr_t</a><a id='6039' tid='6040', class="m">*</a>&gt;(<a id='6041' tid='6042', class="m">addr</a>);
    <span class="d">return *ptr;</span>
  }
  <a id='5995' tid='5996', class="m">PrintF</a>(<a id='5997' tid='5998', class="m">&quot;Unaligned read at 0x%08x, pc=0x%08&quot;</a> <a id='5999' tid='6000', class="m">V8PRIxPTR</a> <a id='6001' tid='6002', class="m">&quot;\n&quot;</a>,
         <a id='6003' tid='6004', class="m">addr</a>,
         <a id='6005' tid='6006', class="m">reinterpret_cast</a>&lt;<a id='6007' tid='6008', class="m">intptr_t</a>&gt;(<a id='6009' tid='6010', class="m">instr</a>));
  <span class="d">MipsDebugger dbg(this)</span>;
  <span class="d">dbg.Debug();</span>
  <span class="d">return 0;</span>
}


<a id='5959' tid='5960', class="m">void</a> <a id='5961' tid='5962', class="m">Simulator</a><a id='5963' tid='5964', class="m">::</a><a id='5965' tid='5966', class="m">WriteW</a>(<a id='5967' tid='5968', class="m">int32_t</a> <a id='5969' tid='5970', class="m">addr</a>, <a id='5971' tid='5972', class="m">int</a> <a id='5973' tid='5974', class="m">value</a>, <a id='5975' tid='5976', class="m">Instruction</a><a id='5977' tid='5978', class="m">*</a> <a id='5979' tid='5980', class="m">instr</a>) {
  <span class="d">if (addr &gt;= 0 && addr &lt; 0x400) {
    // This has to be a NULL-dereference, drop into debugger.
    MipsDebugger dbg(this);
    dbg.Debug();
  }</span>
  <span class="d">if</span> <span class="d">((addr & kPointerAlignmentMask) == 0)</span> {
    <a id='5981' tid='5982', class="m">intptr_t</a><a id='5983' tid='5984', class="m">*</a> <a id='5985' tid='5986', class="m">ptr</a> = <a id='5987' tid='5988', class="m">reinterpret_cast</a>&lt;<a id='5989' tid='5990', class="m">intptr_t</a><a id='5991' tid='5992', class="m">*</a>&gt;(<a id='5993' tid='5994', class="m">addr</a>);
    <span class="d">*ptr = value;</span>
    <span class="d">return;</span>
  }
  <a id='5943' tid='5944', class="m">PrintF</a>(<a id='5945' tid='5946', class="m">&quot;Unaligned write at 0x%08x, pc=0x%08&quot;</a> <a id='5947' tid='5948', class="m">V8PRIxPTR</a> <a id='5949' tid='5950', class="m">&quot;\n&quot;</a>,
         <a id='5951' tid='5952', class="m">addr</a>,
         <a id='5953' tid='5954', class="m">reinterpret_cast</a>&lt;<a id='5955' tid='5956', class="m">intptr_t</a>&gt;(<a id='5957' tid='5958', class="m">instr</a>));
  <span class="d">MipsDebugger dbg(this)</span>;
  <span class="d">dbg.Debug();</span>
}


<span class="d">double</span> <span class="d">Simulator::ReadD</span>(<a id='5933' tid='5934', class="m">int32_t</a> <a id='5935' tid='5936', class="m">addr</a>, <a id='5937' tid='5938', class="m">Instruction</a><a id='5939' tid='5940', class="m">*</a> <a id='5941' tid='5942', class="m">instr</a>) <span class="d">{
  if ((addr & kDoubleAlignmentMask) == 0) {
    double* ptr = reinterpret_cast&lt;double*&gt;(addr);
    return *ptr;
  }
  PrintF(&quot;Unaligned (double) read at 0x%08x, pc=0x%08&quot; V8PRIxPTR &quot;\n&quot;,
         addr,
         reinterpret_cast&lt;intptr_t&gt;(instr));
  OS::Abort();
  return 0;
}</span>


<span class="d">void Simulator::WriteD(int32_t addr, double value, Instruction* instr) {
  if ((addr & kDoubleAlignmentMask) == 0) {
    double* ptr = reinterpret_cast&lt;double*&gt;(addr);
    *ptr = value;
    return;
  }
  PrintF(&quot;Unaligned (double) write at 0x%08x, pc=0x%08&quot; V8PRIxPTR &quot;\n&quot;,
         addr,
         reinterpret_cast&lt;intptr_t&gt;(instr));
  OS::Abort();
}</span>


<a id='5891' tid='5892', class="m">uint16_t</a> <a id='5893' tid='5894', class="m">Simulator</a><a id='5895' tid='5896', class="m">::</a><a id='5897' tid='5898', class="m">ReadHU</a>(<a id='5923' tid='5924', class="m">int32_t</a> <a id='5925' tid='5926', class="m">addr</a>, <a id='5927' tid='5928', class="m">Instruction</a><a id='5929' tid='5930', class="m">*</a> <a id='5931' tid='5932', class="m">instr</a>) {
  <span class="d">if</span> ((<a id='5791' tid='5792', class="m">addr</a> <a id='5793' tid='5794', class="m">&</a> <a id='5795' tid='5796', class="m">1</a>) <a id='5797' tid='5798', class="m">==</a> <a id='5799' tid='5800', class="m">0</a>) {
    <a id='5899' tid='5900', class="m">uint16_t</a><a id='5901' tid='5902', class="m">*</a> <a id='5903' tid='5904', class="m">ptr</a> = <a id='5905' tid='5906', class="m">reinterpret_cast</a>&lt;<a id='5907' tid='5908', class="m">uint16_t</a><a id='5909' tid='5910', class="m">*</a>&gt;(<a id='5911' tid='5912', class="m">addr</a>);
    <span class="d">return *ptr;</span>
  }
  <a id='5875' tid='5876', class="m">PrintF</a>(<a id='5877' tid='5878', class="m">&quot;Unaligned unsigned halfword read at 0x%08x, pc=0x%08&quot;</a> <a id='5879' tid='5880', class="m">V8PRIxPTR</a> <a id='5881' tid='5882', class="m">&quot;\n&quot;</a>,
         <a id='5883' tid='5884', class="m">addr</a>,
         <a id='5885' tid='5886', class="m">reinterpret_cast</a>&lt;<a id='5887' tid='5888', class="m">intptr_t</a>&gt;(<a id='5889' tid='5890', class="m">instr</a>));
  <span class="d">OS::Abort();</span>
  <span class="d">return 0;</span>
}


<a id='5857' tid='5858', class="m">int16_t</a> <a id='5859' tid='5860', class="m">Simulator</a><a id='5861' tid='5862', class="m">::</a><a id='5863' tid='5864', class="m">ReadH</a><span class="d">(int32_t addr, Instruction* instr)</span> {
  <span class="d">if</span> ((<a id='5913' tid='5914', class="m">addr</a> <a id='5915' tid='5916', class="m">&</a> <a id='5917' tid='5918', class="m">1</a>) <a id='5919' tid='5920', class="m">==</a> <a id='5921' tid='5922', class="m">0</a>) {
    <a id='5801' tid='5802', class="m">int16_t</a><a id='5803' tid='5804', class="m">*</a> <a id='5805' tid='5806', class="m">ptr</a> = <a id='5807' tid='5808', class="m">reinterpret_cast</a>&lt;<a id='5809' tid='5810', class="m">int16_t</a><a id='5811' tid='5812', class="m">*</a>&gt;(<a id='5813' tid='5814', class="m">addr</a>);
    <span class="d">return *ptr;</span>
  }
  <span class="d">PrintF(&quot;Unaligned signed halfword read at 0x%08x, pc=0x%08&quot; V8PRIxPTR &quot;\n&quot;,
         addr,
         reinterpret_cast&lt;intptr_t&gt;(instr));</span>
  <span class="d">OS::Abort();</span>
  <span class="d">return 0;</span>
}


<a id='5755' tid='5756', class="m">void</a> <a id='5757' tid='5758', class="m">Simulator</a><a id='5759' tid='5760', class="m">::</a><a id='5761' tid='5762', class="m">WriteH</a>(<a id='5763' tid='5764', class="m">int32_t</a> <a id='5765' tid='5766', class="m">addr</a>, <a id='5767' tid='5768', class="m">uint16_t</a> <a id='5769' tid='5770', class="m">value</a>, <a id='5771' tid='5772', class="m">Instruction</a><a id='5773' tid='5774', class="m">*</a> <a id='5775' tid='5776', class="m">instr</a>) {
  <a id='5831' tid='5832', class="m">if</a> ((<a id='5865' tid='5866', class="m">addr</a> <a id='5867' tid='5868', class="m">&</a> <a id='5869' tid='5870', class="m">1</a>) <a id='5871' tid='5872', class="m">==</a> <a id='5873' tid='5874', class="m">0</a>) {