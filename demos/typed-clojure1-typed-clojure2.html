<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<LINK href="diff.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="nav.js"></script>
</head>
<body>
<div id="left" class="src">
<pre>
<a id='leftstart' tid='rightstart'></a>
<span class='d'>(ns clojure.core.typed
  (:refer-clojure :exclude [defrecord type])
  (:import (clojure.lang IPersistentList IPersistentVector Symbol Cons Seqable IPersistentCollection
                         ISeq ASeq ILookup Var Namespace PersistentVector APersistentVector
                         IFn IPersistentStack Associative IPersistentSet IPersistentMap IMapEntry
                         Keyword Atom PersistentList IMeta PersistentArrayMap Compiler Named
                         IRef AReference ARef IDeref IReference APersistentSet PersistentHashSet Sorted
                         LazySeq APersistentMap))
  (:require [analyze.core :refer [ast] :as analyze]
            [analyze.hygienic :as hygienic]
            [clojure.set :as set]
            [clojure.reflect :as reflect]
            [clojure.string :as str]
            [clojure.repl :refer [pst]]
            [clojure.pprint :refer [pprint]]
            [trammel.core :as contracts]
            [clojure.math.combinatorics :as comb]
            [clojure.java.io :as io]
            [cljs
             [compiler]
             [analyzer :as cljs]]
            [clojure.tools.trace :refer [trace-vars untrace-vars
                                         trace-ns untrace-ns]]))</span>

<span class='d'>(set! *warn-on-reflection* true)</span>


<span class='d'>; constraint shorthands, other handy functions
</span><span class='d'>(load &quot;typed/utils&quot;)</span>

<span class='d'>;Note: defrecord is now trammel&#39;s defconstrainedrecord
</span>
<span class='d'>;(ann analyze.hygienic/emit-hy [Any -&gt; Any])
</span>
<span class='d'>;AnalysisExpr -&gt; Form
</span><span class='d'>;(ann emit-form-fn [Any -&gt; Any])
</span><span class='d'>(def emit-form-fn hygienic/emit-hy)</span>

<span class='d'>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class='d'>;; Special functions
</span>
<span class='d'>;(ann print-filterset [String Any -&gt; Any])
</span>(<a id='781' tid='782' class='u'>defn</a> <a id='783' tid='784' class='u'>print-filterset</a>
  <span class='d'>&quot;Print the filter set attached to form, and debug-string&quot;</span>
  [<a id='785' tid='786' class='u'>debug-string</a> <a id='787' tid='788' class='u'>frm</a>] 
  <a id='789' tid='790' class='u'>frm</a>)

<span class='d'>(declare Method-&gt;Function unparse-type unparse-filter)</span>

<span class='d'>;(ann method-type [Symbol -&gt; nil])
</span>(<a id='671' tid='672' class='u'>defn</a> <a id='673' tid='674' class='u'>method-type</a> 
  <span class='d'>&quot;Given a method symbol, print the core.typed types assigned to it&quot;</span>
  [<a id='675' tid='676' class='u'>mname</a>]
  (<span class='d'>let</span> [<span class='d'>ms</span> (<span class='d'>-&gt;&gt;</span> <span class='d'>(reflect/type-reflect (Class/forName (namespace mname)))</span>
             <span class='d'>:members</span>
             (<a id='171' tid='172' class='m'>filter</a> <a id='173' tid='174' class='m'>#</a>(<a id='175' tid='176' class='m'>and</a> (<a id='177' tid='178' class='m'>instance?</a> <a id='179' tid='180' class='m'>clojure.reflect.Method</a> <a id='181' tid='182' class='m'>%</a>)
                           (<a id='183' tid='184' class='m'>=</a> (<a id='185' tid='186' class='m'>str</a> (<a id='187' tid='188' class='m'>:name</a> <a id='189' tid='190' class='m'>%</a>)) (<a id='191' tid='192' class='m'>name</a> <a id='193' tid='194' class='m'>mname</a>))))
             <span class='d'>set</span>)
        <span class='d'>_</span> (<a id='147' tid='148' class='m'>assert</a> (<a id='149' tid='150' class='m'>seq</a> <a id='151' tid='152' class='m'>ms</a>) (<a id='153' tid='154' class='m'>str</a> <a id='155' tid='156' class='m'>&quot;Method &quot;</a> <a id='157' tid='158' class='m'>mname</a> <a id='159' tid='160' class='m'>&quot; not found&quot;</a>))]
    <span class='d'>(prn &quot;Method name:&quot; mname)</span>
    <span class='d'>(doseq [m ms]
      (prn (unparse-type (Method-&gt;Function m))))</span>))

<span class='d'>;(ann inst-poly [Any Any -&gt; Any])
</span>(<a id='589' tid='590' class='u'>defn</a> <a id='591' tid='592' class='u'>inst-poly</a> 
  [<a id='593' tid='594' class='u'>inst-of</a> <a id='595' tid='596' class='u'>types-syn</a>]
  <a id='597' tid='598' class='u'>inst-of</a>)

<span class='d'>;(ann inst-poly-ctor [Any Any -&gt; Any])
</span>(<a id='599' tid='600' class='u'>defn</a> <a id='601' tid='602' class='u'>inst-poly-ctor</a> [<a id='603' tid='604' class='u'>inst-of</a> <a id='605' tid='606' class='u'>types-syn</a>]
  <a id='607' tid='608' class='u'>inst-of</a>)

(<a id='545' tid='546' class='u'>defmacro</a> <a id='547' tid='548' class='u'>inst</a> 
  <a id='549' tid='550' class='u'>&quot;Instantiate a polymorphic type with a number of types&quot;</a>
  [<a id='551' tid='552' class='u'>inst-of</a> <a id='553' tid='554' class='u'>&</a> <a id='555' tid='556' class='u'>types</a>]
  <a id='557' tid='558' class='u'>`</a>(<a id='559' tid='560' class='u'>inst-poly</a> <a id='561' tid='562' class='u'>~inst-of</a> <a id='563' tid='564' class='u'>&#39;</a><a id='565' tid='566' class='u'>~types</a>))

(<a id='567' tid='568' class='u'>defmacro</a> <a id='569' tid='570' class='u'>inst-ctor</a>
  <a id='571' tid='572' class='u'>&quot;Instantiate a call to a constructor with a number of types.
  First argument must be an immediate call to a constructor.&quot;</a>
  [<a id='573' tid='574' class='u'>inst-of</a> <a id='575' tid='576' class='u'>&</a> <a id='577' tid='578' class='u'>types</a>]
  <a id='579' tid='580' class='u'>`</a>(<a id='581' tid='582' class='u'>inst-poly-ctor</a> <a id='583' tid='584' class='u'>~inst-of</a> <a id='585' tid='586' class='u'>&#39;</a><a id='587' tid='588' class='u'>~types</a>))

<span class='d'>;(ann fn&gt;-ann [Any Any -&gt; Any])
</span>(<a id='535' tid='536' class='u'>defn</a> <a id='537' tid='538' class='u'>fn&gt;-ann</a> [<a id='539' tid='540' class='u'>fn-of</a> <a id='541' tid='542' class='u'>param-types-syn</a>]
  <a id='543' tid='544' class='u'>fn-of</a>)

<span class='d'>;(ann pfn&gt;-ann [Any Any -&gt; Any])
</span>(<a id='761' tid='762' class='u'>defn</a> <a id='763' tid='764' class='u'>pfn&gt;-ann</a> [<a id='765' tid='766' class='u'>fn-of</a> <a id='767' tid='768' class='u'>polys</a> <a id='769' tid='770' class='u'>param-types-syn</a>]
  <a id='771' tid='772' class='u'>fn-of</a>)

<span class='d'>;(ann loop&gt;-ann [Any Any -&gt; Any])
</span>(<a id='661' tid='662' class='u'>defn</a> <a id='663' tid='664' class='u'>loop&gt;-ann</a> [<a id='665' tid='666' class='u'>loop-of</a> <a id='667' tid='668' class='u'>bnding-types</a>]
  <a id='669' tid='670' class='u'>loop-of</a>)

<span class='d'>;(ann doseq&gt;-ann [Any Any -&gt; Any])
</span><span class='d'>(defn doseq&gt;-ann [the-doseq bnding-types body]
  the-doseq)</span>

<span class='d'>;(ann parse-fn&gt; [Any (Seqable Any) -&gt;
</span><span class='d'>;                &#39;{:poly Any
</span><span class='d'>;                  :fn Any ;Form
</span><span class='d'>;                  :parsed-methods (Seqable &#39;{:dom-syntax (Seqable Any)
</span><span class='d'>;                                             :dom-lhs (Seqable Any)
</span><span class='d'>;                                             :rng-syntax Any
</span><span class='d'>;                                             :has-rng? Any
</span><span class='d'>;                                             :body Any})}])
</span><span class='d'>;for
</span>(<a id='195' tid='196' class='m'>defn-</a> <a id='197' tid='198' class='m'>parse-fn&gt;</a>
  <a id='199' tid='200' class='m'>&quot;(fn&gt; name? :- type? [[param :- type]* & [param :- type *]?] exprs*)
  (fn&gt; name? (:- type? [[param :- type]* & [param :- type *]?] exprs*)+)&quot;</a>
  [<a id='201' tid='202' class='m'>is-poly</a> <a id='203' tid='204' class='m'>forms</a>]
  (<a id='205' tid='206' class='m'>let</a> [<span class='d'>name</span> (<a id='207' tid='208' class='m'>when</a> (<a id='209' tid='210' class='m'>symbol?</a> (<a id='211' tid='212' class='m'>first</a> <a id='213' tid='214' class='m'>forms</a>))
               (<a id='215' tid='216' class='m'>first</a> <a id='217' tid='218' class='m'>forms</a>))
        <span class='d'>forms</span> (<a id='161' tid='162' class='m'>if</a> <a id='163' tid='164' class='m'>name</a> (<a id='165' tid='166' class='m'>rest</a> <a id='167' tid='168' class='m'>forms</a>) <a id='169' tid='170' class='m'>forms</a>)
        <span class='d'>poly</span> <span class='d'>(when is-poly
               (first forms))</span>
        <span class='d'>forms</span> (<a id='137' tid='138' class='m'>if</a> <a id='139' tid='140' class='m'>poly</a> (<a id='141' tid='142' class='m'>rest</a> <a id='143' tid='144' class='m'>forms</a>) <a id='145' tid='146' class='m'>forms</a>)
        <span class='d'>methods</span> (<a id='119' tid='120' class='m'>if</a> ((<a id='121' tid='122' class='m'>some-fn</a> <a id='123' tid='124' class='m'>vector?</a> <a id='125' tid='126' class='m'>keyword?</a>) (<a id='127' tid='128' class='m'>first</a> <a id='129' tid='130' class='m'>forms</a>))
                  (<a id='131' tid='132' class='m'>list</a> <a id='133' tid='134' class='m'>forms</a>)
                  <a id='135' tid='136' class='m'>forms</a>)
        <span class='d'>;(fn&gt; name? (:- type? [[param :- type]* & [param :- type *]?] exprs*)+)&quot;
</span>        <span class='d'>; (HMap {:dom (Seqable TypeSyntax)
</span>        <span class='d'>;        :rng (U nil TypeSyntax)
</span>        <span class='d'>;        :body Any})
</span>        <span class='d'>parsed-methods</span> (<a id='25' tid='26' class='m'>doall</a> 
                         (<a id='27' tid='28' class='m'>for</a> [<a id='29' tid='30' class='m'>method</a> <a id='31' tid='32' class='m'>methods</a>]
                           (<a id='33' tid='34' class='m'>let</a> [<span class='d'>[ret has-ret?]</span> (<a id='35' tid='36' class='m'>when</a> (<a id='37' tid='38' class='m'>not</a> (<a id='39' tid='40' class='m'>vector?</a> (<a id='41' tid='42' class='m'>first</a> <a id='43' tid='44' class='m'>method</a>)))
                                                  (<a id='45' tid='46' class='m'>assert</a> (<a id='47' tid='48' class='m'>=</a> <a id='49' tid='50' class='m'>:-</a> (<a id='51' tid='52' class='m'>first</a> <a id='53' tid='54' class='m'>method</a>))
                                                          <a id='55' tid='56' class='m'>&quot;Return type for fn&gt; must be prefixed by :-&quot;</a>)
                                                  [(<a id='57' tid='58' class='m'>second</a> <a id='59' tid='60' class='m'>method</a>) <a id='61' tid='62' class='m'>true</a>])
                                 <span class='d'>method</span> (<a id='15' tid='16' class='m'>if</a> <a id='17' tid='18' class='m'>ret</a> 
                                          (<a id='19' tid='20' class='m'>nnext</a> <a id='21' tid='22' class='m'>method</a>)
                                          <a id='23' tid='24' class='m'>method</a>)
                                 <span class='d'>body</span> <span class='d'>(rest method)</span>
                                 <span class='d'>arg-anns</span> <span class='d'>(first method)</span>
                                 <span class='d'>[required-params _ [rest-param]]</span> (<a id='1' tid='2' class='m'>split-with</a> <a id='3' tid='4' class='m'>#</a>(<a id='5' tid='6' class='m'>not=</a> <a id='7' tid='8' class='m'>&#39;</a><a id='9' tid='10' class='m'>&</a> <a id='11' tid='12' class='m'>%</a>) <a id='13' tid='14' class='m'>arg-anns</a>)]
                             (<a id='63' tid='64' class='m'>assert</a> (<a id='65' tid='66' class='m'>sequential?</a> <a id='67' tid='68' class='m'>required-params</a>)
                                     <a id='69' tid='70' class='m'>&quot;Must provide a sequence of typed parameters to fn&gt;&quot;</a>)
                             (<a id='71' tid='72' class='m'>assert</a> (<a id='73' tid='74' class='m'>not</a> <a id='75' tid='76' class='m'>rest-param</a>) <a id='77' tid='78' class='m'>&quot;fn&gt; doesn&#39;t support rest parameters yet&quot;</a>)
                             <a id='79' tid='80' class='m'>{</a><a id='81' tid='82' class='m'>:dom-syntax</a> (<a id='83' tid='84' class='m'>doall</a> (<a id='85' tid='86' class='m'>map</a> (<a id='87' tid='88' class='m'>comp</a> <a id='89' tid='90' class='m'>second</a> <a id='91' tid='92' class='m'>next</a>) <a id='93' tid='94' class='m'>required-params</a>))
                              <a id='95' tid='96' class='m'>:dom-lhs</a> (<a id='97' tid='98' class='m'>doall</a> (<a id='99' tid='100' class='m'>map</a> <a id='101' tid='102' class='m'>first</a> <a id='103' tid='104' class='m'>required-params</a>))
                              <a id='105' tid='106' class='m'>:rng-syntax</a> <a id='107' tid='108' class='m'>ret</a>
                              <a id='109' tid='110' class='m'>:has-rng?</a> <a id='111' tid='112' class='m'>has-ret?</a>
                              <a id='113' tid='114' class='m'>:body</a> <a id='115' tid='116' class='m'>body</a><a id='117' tid='118' class='m'>}</a>)))]
    <a id='219' tid='220' class='m'>{</a><a id='221' tid='222' class='m'>:poly</a> <a id='223' tid='224' class='m'>poly</a>
     <a id='225' tid='226' class='m'>:fn</a> <a id='227' tid='228' class='m'>`</a>(<a id='229' tid='230' class='m'>fn</a> <a id='231' tid='232' class='m'>~@</a>(<a id='233' tid='234' class='m'>concat</a>
                  (<a id='235' tid='236' class='m'>when</a> <a id='237' tid='238' class='m'>name</a>
                    [<a id='239' tid='240' class='m'>name</a>])
                  (<a id='241' tid='242' class='m'>for</a> [<a id='243' tid='244' class='m'>{</a><a id='245' tid='246' class='m'>:keys</a> [<a id='247' tid='248' class='m'>body</a> <a id='249' tid='250' class='m'>dom-lhs</a>]<a id='251' tid='252' class='m'>}</a> <a id='253' tid='254' class='m'>parsed-methods</a>]
                    (<a id='255' tid='256' class='m'>apply</a> <a id='257' tid='258' class='m'>list</a> (<a id='259' tid='260' class='m'>vec</a> <a id='261' tid='262' class='m'>dom-lhs</a>) <a id='263' tid='264' class='m'>body</a>))))
     <a id='265' tid='266' class='m'>:parsed-methods</a> <a id='267' tid='268' class='m'>parsed-methods</a><a id='269' tid='270' class='m'>}</a>))

(<a id='717' tid='718' class='u'>defmacro</a> <a id='719' tid='720' class='u'>pfn&gt;</a> 
  <a id='721' tid='722' class='u'>&quot;Define a polymorphic typed anonymous function.
  (pfn&gt; name? [binder+] :- type? [[param :- type]* & [param :- type *]?] exprs*)
  (pfn&gt; name? [binder+] (:- type? [[param :- type]* & [param :- type *]?] exprs*)+)&quot;</a>
  [<a id='723' tid='724' class='u'>&</a> <a id='725' tid='726' class='u'>forms</a>]
  (<a id='727' tid='728' class='u'>let</a> [<a id='729' tid='730' class='u'>{</a><a id='731' tid='732' class='u'>:keys</a> [<a id='733' tid='734' class='u'>poly</a> <a id='735' tid='736' class='u'>fn</a> <a id='737' tid='738' class='u'>parsed-methods</a>]<a id='739' tid='740' class='u'>}</a> (<a id='741' tid='742' class='u'>parse-fn&gt;</a> <a id='743' tid='744' class='u'>true</a> <a id='745' tid='746' class='u'>forms</a>)]
    <a id='747' tid='748' class='u'>`</a>(<a id='749' tid='750' class='u'>pfn&gt;-ann</a> <a id='751' tid='752' class='u'>~fn</a> <a id='753' tid='754' class='u'>&#39;</a><a id='755' tid='756' class='u'>~poly</a> <a id='757' tid='758' class='u'>&#39;</a><a id='759' tid='760' class='u'>~parsed-methods</a>)))

(<a id='497' tid='498' class='u'>defmacro</a> <a id='499' tid='500' class='u'>fn&gt;</a> 
  <a id='501' tid='502' class='u'>&quot;Define a typed anonymous function.
  (fn&gt; name? :- type? [[param :- type]* & [param :- type *]?] exprs*)
  (fn&gt; name? (:- type? [[param :- type]* & [param :- type *]?] exprs*)+)&quot;</a>
  [<a id='503' tid='504' class='u'>&</a> <a id='505' tid='506' class='u'>forms</a>]
  (<a id='507' tid='508' class='u'>let</a> [<a id='509' tid='510' class='u'>{</a><a id='511' tid='512' class='u'>:keys</a> [<a id='513' tid='514' class='u'>fn</a> <a id='515' tid='516' class='u'>parsed-methods</a>]<a id='517' tid='518' class='u'>}</a> (<a id='519' tid='520' class='u'>parse-fn&gt;</a> <a id='521' tid='522' class='u'>false</a> <a id='523' tid='524' class='u'>forms</a>)]
    <a id='525' tid='526' class='u'>`</a>(<a id='527' tid='528' class='u'>fn&gt;-ann</a> <a id='529' tid='530' class='u'>~fn</a> <a id='531' tid='532' class='u'>&#39;</a><a id='533' tid='534' class='u'>~parsed-methods</a>)))

(<a id='481' tid='482' class='u'>defmacro</a> <a id='483' tid='484' class='u'>defprotocol&gt;</a> [<a id='485' tid='486' class='u'>&</a> <a id='487' tid='488' class='u'>body</a>]
  <span class='d'>&quot;Define a typed protocol&quot;</span>
  <a id='489' tid='490' class='u'>`</a>(<a id='491' tid='492' class='u'>tc-ignore</a>
     (<a id='493' tid='494' class='u'>defprotocol</a> <a id='495' tid='496' class='u'>~@body</a>)))

(<a id='651' tid='652' class='u'>defmacro</a> <a id='653' tid='654' class='u'>loop&gt;</a>
  <span class='d'>&quot;Define a typed loop&quot;</span>
  [<a id='655' tid='656' class='u'>bndings*</a> <a id='657' tid='658' class='u'>&</a> <a id='659' tid='660' class='u'>forms</a>]
  (<a id='271' tid='272' class='m'>let</a> [<span class='d'>bnds</span> <span class='d'>(partition 2 bndings*)</span>
        <span class='d'>; [[lhs :- bnd-ann] rhs]
</span>        <span class='d'>lhs</span> <span class='d'>(map ffirst bnds)</span>
        <span class='d'>rhs</span> <span class='d'>(map second bnds)</span>
        <span class='d'>bnd-anns</span> (<a id='273' tid='274' class='m'>map</a> <a id='275' tid='276' class='m'>#</a>(<a id='277' tid='278' class='m'>-&gt;</a> <a id='279' tid='280' class='m'>%</a> <a id='281' tid='282' class='m'>first</a> <a id='283' tid='284' class='m'>next</a> <a id='285' tid='286' class='m'>second</a>) <a id='287' tid='288' class='m'>bnds</a>)]
    <a id='289' tid='290' class='m'>`</a>(<a id='291' tid='292' class='m'>loop&gt;-ann</a> (<a id='293' tid='294' class='m'>loop</a> <a id='295' tid='296' class='m'>~</a>(<a id='297' tid='298' class='m'>vec</a> (<a id='299' tid='300' class='m'>mapcat</a> <a id='301' tid='302' class='m'>vector</a> <a id='303' tid='304' class='m'>lhs</a> <a id='305' tid='306' class='m'>rhs</a>))
                  <a id='307' tid='308' class='m'>~@forms</a>)
                <a id='309' tid='310' class='m'>&#39;</a><a id='311' tid='312' class='m'>~bnd-anns</a>)))

(<a id='441' tid='442' class='u'>defmacro</a> <a id='443' tid='444' class='u'>declare-datatypes</a> 
  <a id='445' tid='446' class='u'>&quot;Declare datatypes, similar to declare but on the type level.&quot;</a>
  [<a id='447' tid='448' class='u'>&</a> <a id='449' tid='450' class='u'>syms</a>]
  <a id='451' tid='452' class='u'>`</a><span class='d'>(tc-ignore
  (doseq [sym# &#39;~syms]
    (assert (not (or (some #(= \. %) (str sym#))
                     (namespace sym#)))
            (str &quot;Cannot declare qualified datatype: &quot; sym#))
    (let [qsym# (symbol (str (munge (name (ns-name *ns*))) \. (name sym#)))]
      (declare-datatype* qsym#))))</span>)

(<a id='465' tid='466' class='u'>defmacro</a> <a id='467' tid='468' class='u'>declare-protocols</a> 
  <a id='469' tid='470' class='u'>&quot;Declare protocols, similar to declare but on the type level.&quot;</a>
  [<a id='471' tid='472' class='u'>&</a> <a id='473' tid='474' class='u'>syms</a>]
  <a id='475' tid='476' class='u'>`</a><span class='d'>(tc-ignore
  (doseq [sym# &#39;~syms]
     (let [qsym# (if (namespace sym#)
                   sym#
                   (symbol (str (name (ns-name *ns*))) (name sym#)))]
       (declare-protocol* qsym#))))</span>)

(<a id='429' tid='430' class='u'>defmacro</a> <a id='431' tid='432' class='u'>declare-alias-kind</a>
  <a id='433' tid='434' class='u'>&quot;Declare a kind for an alias, similar to declare but on the kind level.&quot;</a>
  [<a id='435' tid='436' class='u'>sym</a> <a id='437' tid='438' class='u'>ty</a>]
  <a id='439' tid='440' class='u'>`</a><span class='d'>(tc-ignore
   (do (ensure-clojure)
     (let [sym# &#39;~sym
           qsym# (if (namespace sym#)
                   sym#
                   (symbol (name (ns-name *ns*)) (name sym#)))
           ty# (parse-type &#39;~ty)]
       (assert (not (namespace sym#)) (str &quot;Cannot declare qualified name &quot; sym#))
       (declare ~sym)
       (declare-names ~sym)
       (declare-alias-kind* qsym# ty#))))</span>)

(<a id='453' tid='454' class='u'>defmacro</a> <a id='455' tid='456' class='u'>declare-names</a> 
  <a id='457' tid='458' class='u'>&quot;Declare names, similar to declare but on the type level.&quot;</a>
  [<a id='459' tid='460' class='u'>&</a> <a id='461' tid='462' class='u'>syms</a>]
  <a id='463' tid='464' class='u'>`</a><span class='d'>(tc-ignore
  (doseq [sym# &#39;~syms]
     (let [qsym# (if (namespace sym#)
                   sym#
                   (symbol (name (ns-name *ns*)) (name sym#)))]
       (declare-name* qsym#))))</span>)

(<a id='477' tid='478' class='u'>defmacro</a> <a id='479' tid='480' class='u'>def-alias</a> 
  <span class='d'>&quot;Define a type alias&quot;</span>
  <span class='d'>[sym type]</span>
  <span class='d'>`</span><span class='d'>(tc-ignore
  (do (ensure-clojure)
    (let [sym# (if (namespace &#39;~sym)
                 &#39;~sym
                 (symbol (name (ns-name *ns*)) (name &#39;~sym)))
          ty# (parse-type &#39;~type)]
      (add-type-name sym# ty#)
      (declare ~sym)
      (when-let [tfn# (@DECLARED-KIND-ENV sym#)]
        (assert (subtype? ty# tfn#) (error-msg &quot;Declared kind &quot; (unparse-type tfn#)
                                               &quot; does not match actual kind &quot; (unparse-type ty#))))
      [sym# (unparse-type ty#)])))</span>)

<span class='d'>(declare Type? RClass? PrimitiveArray? RClass-&gt;Class parse-type symbol-&gt;Class
         requires-resolving? -resolve Nil? Value? Value-&gt;Class Union? Intersection?)</span>

<span class='d'>;Return a Class that generalises what this Clojure type will look like from Java,
</span><span class='d'>;suitable  for use as a Java primitive array member type.
</span><span class='d'>; 
</span><span class='d'>; (Type-&gt;array-member-Class (parse-type &#39;nil)) =&gt; Object
</span><span class='d'>; (Type-&gt;array-member-Class (parse-type &#39;(U nil Number))) =&gt; Number
</span><span class='d'>; (Type-&gt;array-member-Class (parse-type &#39;(Array (U nil Number)))) =~&gt; (Array Number)
</span>
<span class='d'>;(ann Type-&gt;array-member-Class (Fn [Type -&gt; (Option Class)]
</span><span class='d'>;                                  [Type Any -&gt; (Option Class)]))
</span><span class='d'>(defn Type-&gt;array-member-Class 
  ([ty] (Type-&gt;array-member-Class ty false))
  ([ty nilok?]
   {:pre [(Type? ty)]}
   (cond
     (requires-resolving? ty) (Type-&gt;array-member-Class (-resolve ty) nilok?)
     (Nil? ty) (if nilok?
                 nil
                 Object)
     (Value? ty) (Value-&gt;Class ty)
     ;; handles most common case of (U nil Type)
     (Union? ty) (let [clss (map #(Type-&gt;array-member-Class % true) (:types ty))
                       prim-and-nil? (and (some nil? clss)
                                          (some #(when % (.isPrimitive ^Class %)) clss))
                       nonil-clss (remove nil? clss)]
                   (if (and (= 1 (count nonil-clss))
                            (not prim-and-nil?))
                     (first nonil-clss)
                     Object))
     (Intersection? ty) Object
     (RClass? ty) (RClass-&gt;Class ty)
     (PrimitiveArray? ty) (class (make-array (Type-&gt;array-member-Class (:jtype ty) false) 0))
     :else Object)))</span>

<span class='d'>;(ann into-array&gt;* [Any Any -&gt; Any])
</span>(<a id='647' tid='648' class='u'>defn</a> <a id='649' tid='650' class='u'>into-array&gt;*</a> 
  <span class='d'>([cljt coll]
   (into-array (-&gt; cljt parse-type Type-&gt;array-member-Class) coll))</span>
  <span class='d'>([javat cljt coll]
   (into-array (-&gt; javat parse-type Type-&gt;array-member-Class) coll))</span>)

(<a id='609' tid='610' class='u'>defmacro</a> <a id='611' tid='612' class='u'>into-array&gt;</a> 
  <span class='d'>&quot;Make a Java array with Java class javat and Typed Clojure type
  cljt. Resulting array will be of type javat, but elements of coll must be under
  cljt. cljt should be a subtype of javat (the same or more specific).&quot;</span>
  ([<a id='613' tid='614' class='u'>cljt</a> <a id='615' tid='616' class='u'>coll</a>]
   <a id='617' tid='618' class='u'>`</a>(<a id='619' tid='620' class='u'>into-array&gt;*</a> <a id='621' tid='622' class='u'>&#39;</a><a id='623' tid='624' class='u'>~cljt</a> <a id='625' tid='626' class='u'>~coll</a>))
  ([<a id='627' tid='628' class='u'>javat</a> <a id='629' tid='630' class='u'>cljt</a> <a id='631' tid='632' class='u'>coll</a>]
   <a id='633' tid='634' class='u'>`</a>(<a id='635' tid='636' class='u'>into-array&gt;*</a> <a id='637' tid='638' class='u'>&#39;</a><a id='639' tid='640' class='u'>~javat</a> <a id='641' tid='642' class='u'>&#39;</a><a id='643' tid='644' class='u'>~cljt</a> <a id='645' tid='646' class='u'>~coll</a>)))

(<a id='365' tid='366' class='u'>defn</a> <a id='367' tid='368' class='u'>ann-form*</a> [<a id='369' tid='370' class='u'>form</a> <a id='371' tid='372' class='u'>ty</a>]
  <a id='373' tid='374' class='u'>form</a>)

(<a id='347' tid='348' class='u'>defmacro</a> <a id='349' tid='350' class='u'>ann-form</a> [<a id='351' tid='352' class='u'>form</a> <a id='353' tid='354' class='u'>ty</a>]
  <a id='355' tid='356' class='u'>`</a>(<a id='357' tid='358' class='u'>ann-form*</a> <a id='359' tid='360' class='u'>~form</a> <a id='361' tid='362' class='u'>&#39;</a><a id='363' tid='364' class='u'>~ty</a>))

<span class='d'>;(ann unsafe-ann-form* [Any Any -&gt; Any])
</span><span class='d'>(defn unsafe-ann-form* [form ty]
  form)</span>

<span class='d'>(defmacro unsafe-ann-form [form ty]
  `(unsafe-ann-form* ~form &#39;~ty))</span>

<span class='d'>;(ann tc-ignore-forms* [Any -&gt; Any])
</span>(<a id='821' tid='822' class='u'>defn</a> <a id='823' tid='824' class='u'>tc-ignore-forms*</a> [<a id='825' tid='826' class='u'>r</a>]
  <a id='827' tid='828' class='u'>r</a>)

<span class='d'>;; `do` is special at the top level
</span>(<a id='791' tid='792' class='u'>defmacro</a> <a id='793' tid='794' class='u'>tc-ignore</a> 
  <a id='795' tid='796' class='u'>&quot;Ignore forms in body during type checking&quot;</a>
  [<a id='797' tid='798' class='u'>&</a> <a id='799' tid='800' class='u'>body</a>]
  <a id='801' tid='802' class='u'>`</a>(<a id='803' tid='804' class='u'>do</a> <a id='805' tid='806' class='u'>~@</a>(<a id='807' tid='808' class='u'>map</a> (<a id='809' tid='810' class='u'>fn</a> [<a id='811' tid='812' class='u'>b</a>] <a id='813' tid='814' class='u'>`</a>(<a id='815' tid='816' class='u'>tc-ignore-forms*</a> <a id='817' tid='818' class='u'>~b</a>)) <a id='819' tid='820' class='u'>body</a>)))

(<a id='687' tid='688' class='u'>defmacro</a> <a id='689' tid='690' class='u'>non-nil-return</a> 
  <span class='d'>&quot;Override the return type of method msym to be non-nil.
  Takes a set of relevant arities,
  represented by 