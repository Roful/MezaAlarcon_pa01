<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<LINK href="diff.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="nav.js"></script>
</head>
<body>
<div id="left" class="src">
<pre>
<a id='leftstart' tid='rightstart'></a>
<span class='d'>(ns clojure.core.typed
  (:refer-clojure :exclude [defrecord type])
  (:import (clojure.lang IPersistentList IPersistentVector Symbol Cons Seqable IPersistentCollection
                         ISeq ASeq ILookup Var Namespace PersistentVector APersistentVector
                         IFn IPersistentStack Associative IPersistentSet IPersistentMap IMapEntry
                         Keyword Atom PersistentList IMeta PersistentArrayMap Compiler Named
                         IRef AReference ARef IDeref IReference APersistentSet PersistentHashSet Sorted
                         LazySeq APersistentMap))
  (:require [analyze.core :refer [ast] :as analyze]
            [analyze.hygienic :as hygienic]
            [clojure.set :as set]
            [clojure.reflect :as reflect]
            [clojure.string :as str]
            [clojure.repl :refer [pst]]
            [clojure.pprint :refer [pprint]]
            [trammel.core :as contracts]
            [clojure.math.combinatorics :as comb]
            [clojure.java.io :as io]
            [cljs
             [compiler]
             [analyzer :as cljs]]
            [clojure.tools.trace :refer [trace-vars untrace-vars
                                         trace-ns untrace-ns]]))</span>

<span class='d'>(set! *warn-on-reflection* true)</span>


<span class='d'>; constraint shorthands, other handy functions
</span><span class='d'>(load &quot;typed/utils&quot;)</span>

<span class='d'>;Note: defrecord is now trammel&#39;s defconstrainedrecord
</span>
<span class='d'>;(ann analyze.hygienic/emit-hy [Any -&gt; Any])
</span>
<span class='d'>;AnalysisExpr -&gt; Form
</span><span class='d'>;(ann emit-form-fn [Any -&gt; Any])
</span><span class='d'>(def emit-form-fn hygienic/emit-hy)</span>

<span class='d'>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class='d'>;; Special functions
</span>
<span class='d'>;(ann print-filterset [String Any -&gt; Any])
</span>(<a id='781' tid='782' class='u'>defn</a> <a id='783' tid='784' class='u'>print-filterset</a>
  <span class='d'>&quot;Print the filter set attached to form, and debug-string&quot;</span>
  [<a id='785' tid='786' class='u'>debug-string</a> <a id='787' tid='788' class='u'>frm</a>] 
  <a id='789' tid='790' class='u'>frm</a>)

<span class='d'>(declare Method-&gt;Function unparse-type unparse-filter)</span>

<span class='d'>;(ann method-type [Symbol -&gt; nil])
</span>(<a id='671' tid='672' class='u'>defn</a> <a id='673' tid='674' class='u'>method-type</a> 
  <span class='d'>&quot;Given a method symbol, print the core.typed types assigned to it&quot;</span>
  [<a id='675' tid='676' class='u'>mname</a>]
  (<span class='d'>let</span> [<span class='d'>ms</span> (<span class='d'>-&gt;&gt;</span> <span class='d'>(reflect/type-reflect (Class/forName (namespace mname)))</span>
             <span class='d'>:members</span>
             (<a id='171' tid='172' class='m'>filter</a> <a id='173' tid='174' class='m'>#</a>(<a id='175' tid='176' class='m'>and</a> (<a id='177' tid='178' class='m'>instance?</a> <a id='179' tid='180' class='m'>clojure.reflect.Method</a> <a id='181' tid='182' class='m'>%</a>)
                           (<a id='183' tid='184' class='m'>=</a> (<a id='185' tid='186' class='m'>str</a> (<a id='187' tid='188' class='m'>:name</a> <a id='189' tid='190' class='m'>%</a>)) (<a id='191' tid='192' class='m'>name</a> <a id='193' tid='194' class='m'>mname</a>))))
             <span class='d'>set</span>)
        <span class='d'>_</span> (<a id='147' tid='148' class='m'>assert</a> (<a id='149' tid='150' class='m'>seq</a> <a id='151' tid='152' class='m'>ms</a>) (<a id='153' tid='154' class='m'>str</a> <a id='155' tid='156' class='m'>&quot;Method &quot;</a> <a id='157' tid='158' class='m'>mname</a> <a id='159' tid='160' class='m'>&quot; not found&quot;</a>))]
    <span class='d'>(prn &quot;Method name:&quot; mname)</span>
    <span class='d'>(doseq [m ms]
      (prn (unparse-type (Method-&gt;Function m))))</span>))

<span class='d'>;(ann inst-poly [Any Any -&gt; Any])
</span>(<a id='589' tid='590' class='u'>defn</a> <a id='591' tid='592' class='u'>inst-poly</a> 
  [<a id='593' tid='594' class='u'>inst-of</a> <a id='595' tid='596' class='u'>types-syn</a>]
  <a id='597' tid='598' class='u'>inst-of</a>)

<span class='d'>;(ann inst-poly-ctor [Any Any -&gt; Any])
</span>(<a id='599' tid='600' class='u'>defn</a> <a id='601' tid='602' class='u'>inst-poly-ctor</a> [<a id='603' tid='604' class='u'>inst-of</a> <a id='605' tid='606' class='u'>types-syn</a>]
  <a id='607' tid='608' class='u'>inst-of</a>)

(<a id='545' tid='546' class='u'>defmacro</a> <a id='547' tid='548' class='u'>inst</a> 
  <a id='549' tid='550' class='u'>&quot;Instantiate a polymorphic type with a number of types&quot;</a>
  [<a id='551' tid='552' class='u'>inst-of</a> <a id='553' tid='554' class='u'>&</a> <a id='555' tid='556' class='u'>types</a>]
  <a id='557' tid='558' class='u'>`</a>(<a id='559' tid='560' class='u'>inst-poly</a> <a id='561' tid='562' class='u'>~inst-of</a> <a id='563' tid='564' class='u'>&#39;</a><a id='565' tid='566' class='u'>~types</a>))

(<a id='567' tid='568' class='u'>defmacro</a> <a id='569' tid='570' class='u'>inst-ctor</a>
  <a id='571' tid='572' class='u'>&quot;Instantiate a call to a constructor with a number of types.
  First argument must be an immediate call to a constructor.&quot;</a>
  [<a id='573' tid='574' class='u'>inst-of</a> <a id='575' tid='576' class='u'>&</a> <a id='577' tid='578' class='u'>types</a>]
  <a id='579' tid='580' class='u'>`</a>(<a id='581' tid='582' class='u'>inst-poly-ctor</a> <a id='583' tid='584' class='u'>~inst-of</a> <a id='585' tid='586' class='u'>&#39;</a><a id='587' tid='588' class='u'>~types</a>))

<span class='d'>;(ann fn&gt;-ann [Any Any -&gt; Any])
</span>(<a id='535' tid='536' class='u'>defn</a> <a id='537' tid='538' class='u'>fn&gt;-ann</a> [<a id='539' tid='540' class='u'>fn-of</a> <a id='541' tid='542' class='u'>param-types-syn</a>]
  <a id='543' tid='544' class='u'>fn-of</a>)

<span class='d'>;(ann pfn&gt;-ann [Any Any -&gt; Any])
</span>(<a id='761' tid='762' class='u'>defn</a> <a id='763' tid='764' class='u'>pfn&gt;-ann</a> [<a id='765' tid='766' class='u'>fn-of</a> <a id='767' tid='768' class='u'>polys</a> <a id='769' tid='770' class='u'>param-types-syn</a>]
  <a id='771' tid='772' class='u'>fn-of</a>)

<span class='d'>;(ann loop&gt;-ann [Any Any -&gt; Any])
</span>(<a id='661' tid='662' class='u'>defn</a> <a id='663' tid='664' class='u'>loop&gt;-ann</a> [<a id='665' tid='666' class='u'>loop-of</a> <a id='667' tid='668' class='u'>bnding-types</a>]
  <a id='669' tid='670' class='u'>loop-of</a>)

<span class='d'>;(ann doseq&gt;-ann [Any Any -&gt; Any])
</span><span class='d'>(defn doseq&gt;-ann [the-doseq bnding-types body]
  the-doseq)</span>

<span class='d'>;(ann parse-fn&gt; [Any (Seqable Any) -&gt;
</span><span class='d'>;                &#39;{:poly Any
</span><span class='d'>;                  :fn Any ;Form
</span><span class='d'>;                  :parsed-methods (Seqable &#39;{:dom-syntax (Seqable Any)
</span><span class='d'>;                                             :dom-lhs (Seqable Any)
</span><span class='d'>;                                             :rng-syntax Any
</span><span class='d'>;                                             :has-rng? Any
</span><span class='d'>;                                             :body Any})}])
</span><span class='d'>;for
</span>(<a id='195' tid='196' class='m'>defn-</a> <a id='197' tid='198' class='m'>parse-fn&gt;</a>
  <a id='199' tid='200' class='m'>&quot;(fn&gt; name? :- type? [[param :- type]* & [param :- type *]?] exprs*)
  (fn&gt; name? (:- type? [[param :- type]* & [param :- type *]?] exprs*)+)&quot;</a>
  [<a id='201' tid='202' class='m'>is-poly</a> <a id='203' tid='204' class='m'>forms</a>]
  (<a id='205' tid='206' class='m'>let</a> [<span class='d'>name</span> (<a id='207' tid='208' class='m'>when</a> (<a id='209' tid='210' class='m'>symbol?</a> (<a id='211' tid='212' class='m'>first</a> <a id='213' tid='214' class='m'>forms</a>))
               (<a id='215' tid='216' class='m'>first</a> <a id='217' tid='218' class='m'>forms</a>))
        <span class='d'>forms</span> (<a id='161' tid='162' class='m'>if</a> <a id='163' tid='164' class='m'>name</a> (<a id='165' tid='166' class='m'>rest</a> <a id='167' tid='168' class='m'>forms</a>) <a id='169' tid='170' class='m'>forms</a>)
        <span class='d'>poly</span> <span class='d'>(when is-poly
               (first forms))</span>
        <span class='d'>forms</span> (<a id='137' tid='138' class='m'>if</a> <a id='139' tid='140' class='m'>poly</a> (<a id='141' tid='142' class='m'>rest</a> <a id='143' tid='144' class='m'>forms</a>) <a id='145' tid='146' class='m'>forms</a>)
        <span class='d'>methods</span> (<a id='119' tid='120' class='m'>if</a> ((<a id='121' tid='122' class='m'>some-fn</a> <a id='123' tid='124' class='m'>vector?</a> <a id='125' tid='126' class='m'>keyword?</a>) (<a id='127' tid='128' class='m'>first</a> <a id='129' tid='130' class='m'>forms</a>))
                  (<a id='131' tid='132' class='m'>list</a> <a id='133' tid='134' class='m'>forms</a>)
                  <a id='135' tid='136' class='m'>forms</a>)
        <span class='d'>;(fn&gt; name? (:- type? [[param :- type]* & [param :- type *]?] exprs*)+)&quot;
</span>        <span class='d'>; (HMap {:dom (Seqable TypeSyntax)
</span>        <span class='d'>;        :rng (U nil TypeSyntax)
</span>        <span class='d'>;        :body Any})
</span>        <span class='d'>parsed-methods</span> (<a id='25' tid='26' class='m'>doall</a> 
                         (<a id='27' tid='28' class='m'>for</a> [<a id='29' tid='30' class='m'>method</a> <a id='31' tid='32' class='m'>methods</a>]
                           (<a id='33' tid='34' class='m'>let</a> [<span class='d'>[ret has-ret?]</span> (<a id='35' tid='36' class='m'>when</a> (<a id='37' tid='38' class='m'>not</a> (<a id='39' tid='40' class='m'>vector?</a> (<a id='41' tid='42' class='m'>first</a> <a id='43' tid='44' class='m'>method</a>)))
                                                  (<a id='45' tid='46' class='m'>assert</a> (<a id='47' tid='48' class='m'>=</a> <a id='49' tid='50' class='m'>:-</a> (<a id='51' tid='52' class='m'>first</a> <a id='53' tid='54' class='m'>method</a>))
                                                          <a id='55' tid='56' class='m'>&quot;Return type for fn&gt; must be prefixed by :-&quot;</a>)
                                                  [(<a id='57' tid='58' class='m'>second</a> <a id='59' tid='60' class='m'>method</a>) <a id='61' tid='62' class='m'>true</a>])
                                 <span class='d'>method</span> (<a id='15' tid='16' class='m'>if</a> <a id='17' tid='18' class='m'>ret</a> 
                                          (<a id='19' tid='20' class='m'>nnext</a> <a id